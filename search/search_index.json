{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home About this library This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions. The problem Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Base Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently ,the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry. What is a Behavior Tree? A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#about-this-library","text":"This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions.","title":"About this library"},{"location":"#the-problem","text":"Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Base Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently ,the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"The problem"},{"location":"#what-is-a-behavior-tree","text":"A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"What is a Behavior Tree?"},{"location":"BT_basics/","text":"Introduction to BTs Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, ie.e the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that triggers an action. All the other nodes of the tree, those which are not leaves, control the \"flow of execution\". To better understand how this flow takes place , imagine a signal, that we will further call \" tick \" that is executed at the root of the tree and propagates through the branches until it reaches a leave. The result of a tick can be either: SUCCESS FAILURE RUNNING The first two, as their names suggest, inform their parent that their operation was a success or a failure. The latter usually means that the execution of the TreeNode is not completed and it needs more time to return a valid result. The result of a node is propagated back to the parent, that will decide which child should be ticked next or will return a result itself. Types of nodes ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes can have only a single child. ActionNodes are leaves and do not have children. The user should implement their own ActionNodes that perform the actual task. ConditionNodes are equivalent to ActionNodes, with the exeption that they are alwais aotmic (they should not return RUNNING) and they should not alter the state of the system. Note Actions and Conditions differ only in terms of semantic . From an implementation point of view they are the same. Learn by example To better understand how a BehaviorTrees work let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously. In future sections we will more thoughtfully analyze asynchronous actions. Sequence Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . It is important to notice that the children of a ControlNode are ordered . In this case the order of execution is from left to right . A Sequence works as described next: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Fallback returns SUCCESS too. Exercise: find the bug! Expand to read the answer. If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseDoor is skipped. Decorators The goal of a DecoratorNode is either to transform the result it received from the child, to terminate the child, or repeat ticking of the child, depending on the type of Decorator. You can create your own Decorators too. The node Negation is a Decorator that inverts the result returned by its child; Negation followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But there is an error. Can you find it? Exercise: find the bug! Expand to read the answer. If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. Fallback FallbackNodes , known also as \"Selector\" in the literature, Is a node that is used to express, as the name suggests, fallback strategies, ie. what to do if a child return FAILURE. In short, it ticks the children in order, as usual from left to right and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequence and Fallbacks can be combined: In the door open? I not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room. \"Fetch me a beer\" revisited We can now improve the \"Fetch Me a Beer\" example, which leaves the door open if the beer was not there. We use the color \"green\" to represent nodes which will return SUCCESS and \"red\" for those which return FAILURE. Black nodes are never executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both the trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS if we managed to open and clode the fridge. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. We can easily double-check that everything works as usual if GrabBeer returns SUCCESS.","title":"The Basics"},{"location":"BT_basics/#introduction-to-bts","text":"Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, ie.e the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that triggers an action. All the other nodes of the tree, those which are not leaves, control the \"flow of execution\". To better understand how this flow takes place , imagine a signal, that we will further call \" tick \" that is executed at the root of the tree and propagates through the branches until it reaches a leave. The result of a tick can be either: SUCCESS FAILURE RUNNING The first two, as their names suggest, inform their parent that their operation was a success or a failure. The latter usually means that the execution of the TreeNode is not completed and it needs more time to return a valid result. The result of a node is propagated back to the parent, that will decide which child should be ticked next or will return a result itself.","title":"Introduction to BTs"},{"location":"BT_basics/#types-of-nodes","text":"ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes can have only a single child. ActionNodes are leaves and do not have children. The user should implement their own ActionNodes that perform the actual task. ConditionNodes are equivalent to ActionNodes, with the exeption that they are alwais aotmic (they should not return RUNNING) and they should not alter the state of the system. Note Actions and Conditions differ only in terms of semantic . From an implementation point of view they are the same.","title":"Types of nodes"},{"location":"BT_basics/#learn-by-example","text":"To better understand how a BehaviorTrees work let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously. In future sections we will more thoughtfully analyze asynchronous actions.","title":"Learn by example"},{"location":"BT_basics/#sequence","text":"Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . It is important to notice that the children of a ControlNode are ordered . In this case the order of execution is from left to right . A Sequence works as described next: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Fallback returns SUCCESS too. Exercise: find the bug! Expand to read the answer. If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseDoor is skipped.","title":"Sequence"},{"location":"BT_basics/#decorators","text":"The goal of a DecoratorNode is either to transform the result it received from the child, to terminate the child, or repeat ticking of the child, depending on the type of Decorator. You can create your own Decorators too. The node Negation is a Decorator that inverts the result returned by its child; Negation followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But there is an error. Can you find it? Exercise: find the bug! Expand to read the answer. If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted.","title":"Decorators"},{"location":"BT_basics/#fallback","text":"FallbackNodes , known also as \"Selector\" in the literature, Is a node that is used to express, as the name suggests, fallback strategies, ie. what to do if a child return FAILURE. In short, it ticks the children in order, as usual from left to right and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequence and Fallbacks can be combined: In the door open? I not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room.","title":"Fallback"},{"location":"BT_basics/#fetch-me-a-beer-revisited","text":"We can now improve the \"Fetch Me a Beer\" example, which leaves the door open if the beer was not there. We use the color \"green\" to represent nodes which will return SUCCESS and \"red\" for those which return FAILURE. Black nodes are never executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both the trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS if we managed to open and clode the fridge. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. We can easily double-check that everything works as usual if GrabBeer returns SUCCESS.","title":"\"Fetch me a beer\" revisited"},{"location":"BlackBoard/","text":"","title":"The BlackBoard"},{"location":"ControlNode/","text":"ControlNodes ControlNodes can have multiple children. Children are always ordered and it is up to the ControlNode itself to decide if and when a child should be ticked. SequenceNode The SequenceNode is used to execute the children in a sequence. It ticks its children as long as they returns SUCCESS. Before ticking the first child, Sequence becomes RUNNING . If a child return SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the Sequence returns SUCCESS . If a child returns RUNNING , Sequence suspends and returns RUNNING . If a child returns FAILURE , Sequence stops and returns FAILURE .","title":"ControlNodes"},{"location":"ControlNode/#controlnodes","text":"ControlNodes can have multiple children. Children are always ordered and it is up to the ControlNode itself to decide if and when a child should be ticked.","title":"ControlNodes"},{"location":"ControlNode/#sequencenode","text":"The SequenceNode is used to execute the children in a sequence. It ticks its children as long as they returns SUCCESS. Before ticking the first child, Sequence becomes RUNNING . If a child return SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the Sequence returns SUCCESS . If a child returns RUNNING , Sequence suspends and returns RUNNING . If a child returns FAILURE , Sequence stops and returns FAILURE .","title":"SequenceNode"},{"location":"DecoratorNode/","text":"Decorators A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked. InverterNode Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too. ForceSuccessNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS. ForceFailureNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE. RepeatNode Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too. RetryNode Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"Decorators Nodes"},{"location":"DecoratorNode/#decorators","text":"A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked.","title":"Decorators"},{"location":"DecoratorNode/#inverternode","text":"Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too.","title":"InverterNode"},{"location":"DecoratorNode/#forcesuccessnode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS.","title":"ForceSuccessNode"},{"location":"DecoratorNode/#forcefailurenode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE.","title":"ForceFailureNode"},{"location":"DecoratorNode/#repeatnode","text":"Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too.","title":"RepeatNode"},{"location":"DecoratorNode/#retrynode","text":"Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"RetryNode"},{"location":"FallbackNode/","text":"Fallback This family of nodes are known as \"Selector\" or, sometimes, \"Priority\" in other frameworks. Its purpose is to try different strategies, until we find one that \"works\". Currently, there is only a single type of node called \"FallbackNode\". FallbackNode The SequenceNode is used to execute the children in a sequence. Before ticking the first child, Fallback becomes RUNNING . If a child returns FAILURE , it ticks the next child. If the last child returns FAILURE too, all the children are halted and the Sequence returns FAILURE . If a child returns RUNNING , Fallback suspends and returns RUNNING . If a child returns SUCCESS , Fallback stops and returns SUCCESS . Example : Try different strategies to open the door. Check first if it is open already. See the pseudocode ``` c++ // At the beginning, start from first child if( state != RUNNING) { index = 0; } state = RUNNING; while( index number_of_children ) { child_state = child[index]- tick(); if( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING; return state; } else if( child_state == FAILURE ) { // continue the while loop index++; } else if( child_state == SUCCESS ) { // Suspend execution and return SUCCESS. // index is reset and children are halted. state = SUCCESS; index = 0; HaltAllChildren(); return state; } } // all the children returned failure. Return FAILURE too. state = FAILURE; HaltAllChildren(); return state;","title":"Fallback Nodes"},{"location":"FallbackNode/#fallback","text":"This family of nodes are known as \"Selector\" or, sometimes, \"Priority\" in other frameworks. Its purpose is to try different strategies, until we find one that \"works\". Currently, there is only a single type of node called \"FallbackNode\".","title":"Fallback"},{"location":"FallbackNode/#fallbacknode","text":"The SequenceNode is used to execute the children in a sequence. Before ticking the first child, Fallback becomes RUNNING . If a child returns FAILURE , it ticks the next child. If the last child returns FAILURE too, all the children are halted and the Sequence returns FAILURE . If a child returns RUNNING , Fallback suspends and returns RUNNING . If a child returns SUCCESS , Fallback stops and returns SUCCESS . Example : Try different strategies to open the door. Check first if it is open already. See the pseudocode ``` c++ // At the beginning, start from first child if( state != RUNNING) { index = 0; } state = RUNNING; while( index number_of_children ) { child_state = child[index]- tick(); if( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING; return state; } else if( child_state == FAILURE ) { // continue the while loop index++; } else if( child_state == SUCCESS ) { // Suspend execution and return SUCCESS. // index is reset and children are halted. state = SUCCESS; index = 0; HaltAllChildren(); return state; } } // all the children returned failure. Return FAILURE too. state = FAILURE; HaltAllChildren(); return state;","title":"FallbackNode"},{"location":"NodeParameters/","text":"NodeParameters","title":"NodeParameters"},{"location":"NodeParameters/#nodeparameters","text":"","title":"NodeParameters"},{"location":"SequenceNode/","text":"Sequences A Sequence ticks all it's children, from left to right, as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Here we introduce different kinds of sequence nodes: SequenceNode SequenceStarNode SequenceAllNode The best way to determine which one should be used is to ask yourself: Q: What should I do if one of the childs returns FAILURE? Use SequenceNode if you answer is: A: Restart the entire sequence Use SequenceStarNode if, instead, the answer is: A: Try again to execute the child that failed. Do not re-tick children which succeeded already. Last, use SequenceAllNode when you want all the children to be ticked at least once. If any of them failed, the SequenceAllNode returns FAILURE. The shared logic is: Before ticking the first child, sequence becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . If a child returns RUNNING , the sequence suspends and returns RUNNING . The next time it is ticked, it will tick the same child again. The three sequences differ in what they do if a child returns FAILURE. SequenceNode (default) If a child returns FAILURE, the sequence returns FAILURE. Reset the index and halt all the children. The entire sequence will be executed again at the next tick. Example : This tree represents the behavior of a sniper in a computer game. If any of these conditions/actions fails, the entire sequence is executed again from the beginning. See the pseudocode // At the beginning, start from first child if ( state != RUNNING ) { index = 0 ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_state == FAILURE ) { // Suspend execution and return FAILURE. // index is reset and children are halted. state = FAILURE ; index = 0 ; HaltAllChildren (); return state ; } } // all the children returned success. Return SUCCESS too. state = SUCCESS ; HaltAllChildren (); return state ; SequenceStarNode If a child returns FAILURE, the sequence returns FAILURE. At the next tick, the failed child is executed again. Example : This is a patrolling agent/robot that must visit locations A, B and C only once. If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK is visited at every tick, because its parent is a normal SequenceNode. See the pseudocode // index is initialized to 0 in the constructor state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_state == FAILURE ) { // Suspend execution and return FAILURE. // At the next tick, index will be the same. state = FAILURE ; return state ; } } // all the children returned success. Return SUCCESS too. state = SUCCESS ; HaltAllChildren (); return state ; SequenceAllNode All the children are executed at least once. If any child returned FAILURE, the sequence is not interrupted but the sequence itself will return FAILURE. Example : If the door of the fridge was succesfully opened, grab a beer. CloseFridge is always executed, even when GrabBeer failed. See the pseudocode if ( state != RUNNING ) { index = 0 ; at_least_one_failure = false ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { index ++ ; } else if ( child_state == FAILURE ) { index ++ ; at_least_one_failure = true ; } } // If any child failed, the entire sequence fails. state = at_least_one_failure ? FAILURE : SUCCESS ; HaltAllChildren (); return state ;","title":"Sequence Nodes"},{"location":"SequenceNode/#sequences","text":"A Sequence ticks all it's children, from left to right, as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Here we introduce different kinds of sequence nodes: SequenceNode SequenceStarNode SequenceAllNode The best way to determine which one should be used is to ask yourself: Q: What should I do if one of the childs returns FAILURE? Use SequenceNode if you answer is: A: Restart the entire sequence Use SequenceStarNode if, instead, the answer is: A: Try again to execute the child that failed. Do not re-tick children which succeeded already. Last, use SequenceAllNode when you want all the children to be ticked at least once. If any of them failed, the SequenceAllNode returns FAILURE. The shared logic is: Before ticking the first child, sequence becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . If a child returns RUNNING , the sequence suspends and returns RUNNING . The next time it is ticked, it will tick the same child again. The three sequences differ in what they do if a child returns FAILURE.","title":"Sequences"},{"location":"SequenceNode/#sequencenode-default","text":"If a child returns FAILURE, the sequence returns FAILURE. Reset the index and halt all the children. The entire sequence will be executed again at the next tick. Example : This tree represents the behavior of a sniper in a computer game. If any of these conditions/actions fails, the entire sequence is executed again from the beginning. See the pseudocode // At the beginning, start from first child if ( state != RUNNING ) { index = 0 ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_state == FAILURE ) { // Suspend execution and return FAILURE. // index is reset and children are halted. state = FAILURE ; index = 0 ; HaltAllChildren (); return state ; } } // all the children returned success. Return SUCCESS too. state = SUCCESS ; HaltAllChildren (); return state ;","title":"SequenceNode (default)"},{"location":"SequenceNode/#sequencestarnode","text":"If a child returns FAILURE, the sequence returns FAILURE. At the next tick, the failed child is executed again. Example : This is a patrolling agent/robot that must visit locations A, B and C only once. If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK is visited at every tick, because its parent is a normal SequenceNode. See the pseudocode // index is initialized to 0 in the constructor state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_state == FAILURE ) { // Suspend execution and return FAILURE. // At the next tick, index will be the same. state = FAILURE ; return state ; } } // all the children returned success. Return SUCCESS too. state = SUCCESS ; HaltAllChildren (); return state ;","title":"SequenceStarNode"},{"location":"SequenceNode/#sequenceallnode","text":"All the children are executed at least once. If any child returned FAILURE, the sequence is not interrupted but the sequence itself will return FAILURE. Example : If the door of the fridge was succesfully opened, grab a beer. CloseFridge is always executed, even when GrabBeer failed. See the pseudocode if ( state != RUNNING ) { index = 0 ; at_least_one_failure = false ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { index ++ ; } else if ( child_state == FAILURE ) { index ++ ; at_least_one_failure = true ; } } // If any child failed, the entire sequence fails. state = at_least_one_failure ? FAILURE : SUCCESS ; HaltAllChildren (); return state ;","title":"SequenceAllNode"},{"location":"getting_started/","text":"","title":"Examples"}]}