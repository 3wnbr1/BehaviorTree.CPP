{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home About this library This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions. What is a Behavior Tree? A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes. \"Ok, but WHY do we need BehaviorTrees (or FSM)?\" Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Base Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently, the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#about-this-library","text":"This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions.","title":"About this library"},{"location":"#what-is-a-behavior-tree","text":"A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"What is a Behavior Tree?"},{"location":"#ok-but-why-do-we-need-behaviortrees-or-fsm","text":"Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Base Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently, the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"\"Ok, but WHY do we need BehaviorTrees (or FSM)?\""},{"location":"BT_basics/","text":"Introduction to BTs Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, i.e. the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that communicate with the \"server\" that performs the operation. In the following example, we can see two Actions executed in a sequence, DetectObject and GraspObject . The other nodes of the tree, those which are not leaves , control the \"flow of execution\". To better understand how this control flow takes place , imagine a signal called \" tick \"; it is executed at the root of the tree and it propagates through the branches until it reaches one or multiple leaves. Note The word tick will be often used as a verb (to tick / to be ticked) and it means \"To invoke the callback tick() called of a TreeNode \". Then a TreeNode is ticked, it returns a NodeStatus that can be either: SUCCESS FAILURE RUNNING IDLE The first two, as their names suggest, inform their parent that their operation was a success or a failure. RUNNING is returned by asynchronous nodes when their execution is not completed and they needs more time to return a valid result. This C++ library provides also the status IDLE ; it means that the node is ready to start. The result of a node is propagated back to its parent, that will decide which child should be ticked next or will return a result to its own parent. Types of nodes ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes is similar to the ControlNode, but it can have only a single child. ActionNodes are leaves and do not have children. The user should implement their own ActionNodes to perform the actual task. ConditionNodes are equivalent to ActionNodes, but they are always atomic, i.e. they must not return RUNNING. They should not alter the state of the system. Examples To better understand how a BehaviorTrees work, let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously. First ControlNode: Sequence Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . The children of a ControlNode are always ordered ; it is up to the ControlNode to consider this order or not. In the graphical representation, the order of execution is from left to right . In short: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Sequence returns SUCCESS too. Have you spotted the bug? If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseFridge is skipped. Decorators The goal of a DecoratorNode is either to transform the result it received from the child, to terminate the child, or repeat ticking of the child, depending on the type of Decorator. You can create your own Decorators. The node Inverter is a Decorator that inverts the result returned by its child; Inverter followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But... Have you spotted the bug? If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. We will see later how we can improve this tree. Second ControlNode: Fallback FallbackNodes , known also as \"Selector\" , are nodes that can express, as the name suggests, fallback strategies, ie. what to do next if a child returns FAILURE. In short, it ticks the children in order and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequence and Fallbacks can be combined: Is the door open? If not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room. \"Fetch me a beer\" revisited We can now improve the \"Fetch Me a Beer\" example, which left the door open if the beer was not inside the fridge. We use the color \"green\" to represent nodes which return SUCCESS and \"red\" for those which return FAILURE. Black nodes are never executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both these trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS if we managed to open and close the fridge. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. Everything works as expected if GrabBeer returns SUCCESS.","title":"Introduction"},{"location":"BT_basics/#introduction-to-bts","text":"Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, i.e. the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that communicate with the \"server\" that performs the operation. In the following example, we can see two Actions executed in a sequence, DetectObject and GraspObject . The other nodes of the tree, those which are not leaves , control the \"flow of execution\". To better understand how this control flow takes place , imagine a signal called \" tick \"; it is executed at the root of the tree and it propagates through the branches until it reaches one or multiple leaves. Note The word tick will be often used as a verb (to tick / to be ticked) and it means \"To invoke the callback tick() called of a TreeNode \". Then a TreeNode is ticked, it returns a NodeStatus that can be either: SUCCESS FAILURE RUNNING IDLE The first two, as their names suggest, inform their parent that their operation was a success or a failure. RUNNING is returned by asynchronous nodes when their execution is not completed and they needs more time to return a valid result. This C++ library provides also the status IDLE ; it means that the node is ready to start. The result of a node is propagated back to its parent, that will decide which child should be ticked next or will return a result to its own parent.","title":"Introduction to BTs"},{"location":"BT_basics/#types-of-nodes","text":"ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes is similar to the ControlNode, but it can have only a single child. ActionNodes are leaves and do not have children. The user should implement their own ActionNodes to perform the actual task. ConditionNodes are equivalent to ActionNodes, but they are always atomic, i.e. they must not return RUNNING. They should not alter the state of the system.","title":"Types of nodes"},{"location":"BT_basics/#examples","text":"To better understand how a BehaviorTrees work, let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously.","title":"Examples"},{"location":"BT_basics/#first-controlnode-sequence","text":"Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . The children of a ControlNode are always ordered ; it is up to the ControlNode to consider this order or not. In the graphical representation, the order of execution is from left to right . In short: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Sequence returns SUCCESS too. Have you spotted the bug? If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseFridge is skipped.","title":"First ControlNode: Sequence"},{"location":"BT_basics/#decorators","text":"The goal of a DecoratorNode is either to transform the result it received from the child, to terminate the child, or repeat ticking of the child, depending on the type of Decorator. You can create your own Decorators. The node Inverter is a Decorator that inverts the result returned by its child; Inverter followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But... Have you spotted the bug? If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. We will see later how we can improve this tree.","title":"Decorators"},{"location":"BT_basics/#second-controlnode-fallback","text":"FallbackNodes , known also as \"Selector\" , are nodes that can express, as the name suggests, fallback strategies, ie. what to do next if a child returns FAILURE. In short, it ticks the children in order and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequence and Fallbacks can be combined: Is the door open? If not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room.","title":"Second ControlNode: Fallback"},{"location":"BT_basics/#fetch-me-a-beer-revisited","text":"We can now improve the \"Fetch Me a Beer\" example, which left the door open if the beer was not inside the fridge. We use the color \"green\" to represent nodes which return SUCCESS and \"red\" for those which return FAILURE. Black nodes are never executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both these trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS if we managed to open and close the fridge. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. Everything works as expected if GrabBeer returns SUCCESS.","title":"\"Fetch me a beer\" revisited"},{"location":"BlackBoard/","text":"","title":"BlackBoard"},{"location":"DecoratorNode/","text":"Decorators A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked. InverterNode Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too. ForceSuccessNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS. ForceFailureNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE. RepeatNode Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too. RetryNode Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"Decorators Nodes"},{"location":"DecoratorNode/#decorators","text":"A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked.","title":"Decorators"},{"location":"DecoratorNode/#inverternode","text":"Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too.","title":"InverterNode"},{"location":"DecoratorNode/#forcesuccessnode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS.","title":"ForceSuccessNode"},{"location":"DecoratorNode/#forcefailurenode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE.","title":"ForceFailureNode"},{"location":"DecoratorNode/#repeatnode","text":"Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too.","title":"RepeatNode"},{"location":"DecoratorNode/#retrynode","text":"Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"RetryNode"},{"location":"FallbackNode/","text":"Fallback This family of nodes are known as \"Selector\" or, sometimes, \"Priority\" in other frameworks. Its purpose is to try different strategies, until we find one that \"works\". Currently the framework provides two kinds of nodes: FallbackNode FallbackStarNode They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns FAILURE , it ticks the next child. If the last child returns FAILURE too, all the children are halted and the sequence returns FAILURE . If a child returns SUCCESS , it stops and returns SUCCESS . All the children are halted. FallbackNode If a child returns RUNNING : FallbackNode returns RUNNING . The loop is restarted and all the previous children are ticked again unless they are ActionNodes . Example : Try different strategies to open the door. Check first if the door is open. See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // index is reset and children are halted. HaltAllChildren (); return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. HaltAllChildren (); return FAILURE ; FallbackStarNode If a child returns RUNNING : FallbackStarNode returns RUNNING . The loop is not restarted and none of the previous children is ticked. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // At the next tick, index will be the same. HaltAllChildren (); index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ;","title":"Fallback Nodes"},{"location":"FallbackNode/#fallback","text":"This family of nodes are known as \"Selector\" or, sometimes, \"Priority\" in other frameworks. Its purpose is to try different strategies, until we find one that \"works\". Currently the framework provides two kinds of nodes: FallbackNode FallbackStarNode They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns FAILURE , it ticks the next child. If the last child returns FAILURE too, all the children are halted and the sequence returns FAILURE . If a child returns SUCCESS , it stops and returns SUCCESS . All the children are halted.","title":"Fallback"},{"location":"FallbackNode/#fallbacknode","text":"If a child returns RUNNING : FallbackNode returns RUNNING . The loop is restarted and all the previous children are ticked again unless they are ActionNodes . Example : Try different strategies to open the door. Check first if the door is open. See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // index is reset and children are halted. HaltAllChildren (); return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. HaltAllChildren (); return FAILURE ;","title":"FallbackNode"},{"location":"FallbackNode/#fallbackstarnode","text":"If a child returns RUNNING : FallbackStarNode returns RUNNING . The loop is not restarted and none of the previous children is ticked. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // At the next tick, index will be the same. HaltAllChildren (); index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ;","title":"FallbackStarNode"},{"location":"NodeParameters/","text":"NodeParameters","title":"NodeParameters"},{"location":"NodeParameters/#nodeparameters","text":"","title":"NodeParameters"},{"location":"SequenceNode/","text":"Sequences A Sequence ticks all it's children as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Currently the framework provides two kinds of nodes: SequenceNode SequenceStarNode They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . SequenceNode If a child returns FAILURE, the sequence returns FAILURE. The index is reset and all the children are halted. If a child returns RUNNING: the sequence returns RUNNING. the loop is restarted and all the previous children are ticked again unless they are ActionNodes . Example : This tree represents the behavior of a sniper in a computer game. If any of these conditions/actions fails, the entire sequence is executed again from the beginning. A running actions will be interrupted if isEnemyVisible becomes false (i.e. it returns FAILURE). See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // Suspend execution and return FAILURE. // index is reset and children are halted. HaltAllChildren (); return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); return SUCCESS ; SequenceStarNode Use this ControlNode when you don't want to tick a child more than once. You can customize its behavior using the NodeParameter \"reset_on_failure\". If a child returns FAILURE, the sequence returns FAILURE. [reset_on_failure = \"true\"]: (default) the loop is restarted. [reset_on_failure = \"false\"]: the same failed child is executed again. If a child returns RUNNING, the sequence returns RUNNING. The same child will be ticked again. Example : This is a patrolling agent/robot that must visit locations A, B and C only once . If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK must be checked at every tick, for this reason its parent must be a SequenceNode. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_status == FAILURE ) { // Suspend execution and return FAILURE. // At the next tick, index will be the same. if ( reset_on_failure ) { HaltAllChildren (); index = 0 ; } return FAILURE ; } } // all the children returned success. Return SUCCESS too. index = 0 ; HaltAllChildren (); return SUCCESS ;","title":"Sequence Nodes"},{"location":"SequenceNode/#sequences","text":"A Sequence ticks all it's children as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Currently the framework provides two kinds of nodes: SequenceNode SequenceStarNode They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS .","title":"Sequences"},{"location":"SequenceNode/#sequencenode","text":"If a child returns FAILURE, the sequence returns FAILURE. The index is reset and all the children are halted. If a child returns RUNNING: the sequence returns RUNNING. the loop is restarted and all the previous children are ticked again unless they are ActionNodes . Example : This tree represents the behavior of a sniper in a computer game. If any of these conditions/actions fails, the entire sequence is executed again from the beginning. A running actions will be interrupted if isEnemyVisible becomes false (i.e. it returns FAILURE). See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // Suspend execution and return FAILURE. // index is reset and children are halted. HaltAllChildren (); return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); return SUCCESS ;","title":"SequenceNode"},{"location":"SequenceNode/#sequencestarnode","text":"Use this ControlNode when you don't want to tick a child more than once. You can customize its behavior using the NodeParameter \"reset_on_failure\". If a child returns FAILURE, the sequence returns FAILURE. [reset_on_failure = \"true\"]: (default) the loop is restarted. [reset_on_failure = \"false\"]: the same failed child is executed again. If a child returns RUNNING, the sequence returns RUNNING. The same child will be ticked again. Example : This is a patrolling agent/robot that must visit locations A, B and C only once . If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK must be checked at every tick, for this reason its parent must be a SequenceNode. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_status == FAILURE ) { // Suspend execution and return FAILURE. // At the next tick, index will be the same. if ( reset_on_failure ) { HaltAllChildren (); index = 0 ; } return FAILURE ; } } // all the children returned success. Return SUCCESS too. index = 0 ; HaltAllChildren (); return SUCCESS ;","title":"SequenceStarNode"},{"location":"getting_started/","text":"Getting started BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS or SmartSoft . You can also statically link it into your application (for example a game). There are some main concepts that you need to understand first. Nodes vs Trees The user must create his/her own ActionNodes and ConditionNodes (LeafNodes) and this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks that you need to compose a complex system. By definition, your custom Nodes are (or should be) highly reusable. Therefore, some wrapping interfaces might be needed at the beginning to adapt your legacy code. The tick() callbacks Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code . What this callback does is up to you. In most of the following examples , our Actions just print messages on the screen of sleep for a certain amount of time to simulate a long calculation. Inheritance vs dependency injection. To create a custom TreeNode, you should inherit from the proper class. For instance, to create your own synchronous Action, you should inherit from the class ActionNodeBase . Alternatively, we provided a mechanism to create a TreeNode passing a function pointer to a wrapper (dependency injection). This approach reduces the amount of boilerplate in your code; as a reference please look at the first tutorial amd the one describing non intrusive integration with legacy code . NodeParameters NodeParameters are conceptually similar to the arguments of a function. They are passed statically when the tree is instantiated. They are expressed as a list of key/value pairs, where both the the key and the value are strings. This is not surprising, since NodeParameters are usually parsed from file. The library provides some methods and utility functions to correctly convert values from string to the desired C++ type. Load trees at run-time using the XML format Despite the fact that the library is written in C++, trees themselves can be composed at run-time, reading the tree structure from file. An XML format is descibed in details here .","title":"Getting started"},{"location":"getting_started/#getting-started","text":"BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS or SmartSoft . You can also statically link it into your application (for example a game). There are some main concepts that you need to understand first.","title":"Getting started"},{"location":"getting_started/#nodes-vs-trees","text":"The user must create his/her own ActionNodes and ConditionNodes (LeafNodes) and this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks that you need to compose a complex system. By definition, your custom Nodes are (or should be) highly reusable. Therefore, some wrapping interfaces might be needed at the beginning to adapt your legacy code.","title":"Nodes vs Trees"},{"location":"getting_started/#the-tick-callbacks","text":"Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code . What this callback does is up to you. In most of the following examples , our Actions just print messages on the screen of sleep for a certain amount of time to simulate a long calculation.","title":"The tick() callbacks"},{"location":"getting_started/#inheritance-vs-dependency-injection","text":"To create a custom TreeNode, you should inherit from the proper class. For instance, to create your own synchronous Action, you should inherit from the class ActionNodeBase . Alternatively, we provided a mechanism to create a TreeNode passing a function pointer to a wrapper (dependency injection). This approach reduces the amount of boilerplate in your code; as a reference please look at the first tutorial amd the one describing non intrusive integration with legacy code .","title":"Inheritance vs dependency injection."},{"location":"getting_started/#nodeparameters","text":"NodeParameters are conceptually similar to the arguments of a function. They are passed statically when the tree is instantiated. They are expressed as a list of key/value pairs, where both the the key and the value are strings. This is not surprising, since NodeParameters are usually parsed from file. The library provides some methods and utility functions to correctly convert values from string to the desired C++ type.","title":"NodeParameters"},{"location":"getting_started/#load-trees-at-run-time-using-the-xml-format","text":"Despite the fact that the library is written in C++, trees themselves can be composed at run-time, reading the tree structure from file. An XML format is descibed in details here .","title":"Load trees at run-time using the XML format"},{"location":"tutorial_A_create_trees/","text":"How to create a BehaviorTree You have mainly two ways to create Behavior Trees. Statically , at compilation time. Dynamically , at run-time, i.e. parsing a file. You are strongly encourage to use the latter approach , but we will describe the former for the sake of completeness. How to create your own ActionNodes You can find the source code here: sample_nodes/dummy_nodes.h . The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom ActionNodeBase (synchronous Action) class ApproachObject : public BT :: ActionNodeBase { public : ApproachObject ( const std :: string name ) : BT :: ActionNodeBase ( name ) {} // You must override this virtual function BT :: NodeStatus tick () override { std :: cout ApproachObject: this - name () std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // You must override this virtual function virtual void halt () override { // Do nothing. This is used by asynchronous nodes only. } }; As you can see: Any instance of a TreeNode has a name. This identifier is meant to be user-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must return a NodeStatus, i.e. RUNNING, SUCCESS or FAILURE. The method halt() is used to stop an asynchronous Action . ApproachObject doesn't need it. Alternatively, we can use dependecy injection to create a TreeNode given a function pointer. The only requirement of the functor is to have either one of these signatures: BT :: NodeStatus myFunction () BT :: NodeStatus myFunction ( BT :: TreeNode self ) For example: using namespace BT ; NodeStatus SayHello () { std :: cout Robot says Hello std :: endl ; return NodeStatus :: SUCCESS ; } class GripperInterface { public : GripperInterface () : _open ( true ) {} NodeStatus open () { _open = true ; std :: cout GripperInterface::open std :: endl ; return NodeStatus :: SUCCESS ; } NodeStatus close () { std :: cout GripperInterface::close std :: endl ; _open = false ; return NodeStatus :: SUCCESS ; } private : bool _open ; }; We can build a SimpleActionNode from any of these functors: SayHello() GripperInterface::open() GripperInterface::close() A static Tree Let's create instances of our TreeNodes and compose them into a tree. BT::SequenceNode is a built-in ControlNode provided by the library. BT::SimpleActionNode is a synchronous ActionNode created passing a functor. DummyNodes::ApproachObject is our user-defined ActionNode. #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; SequenceNode sequence_root ( sequence ); SimpleActionNode say_hello ( action_hello , std :: bind ( SayHello ) ); SimpleActionNode open_gripper ( open_gripper , std :: bind ( GripperInterface :: open , gi ) ); SimpleActionNode close_gripper ( close_gripper , std :: bind ( GripperInterface :: close , gi ) ); ApproachObject approach_object ( approach_object ); // Add children to the sequence. // They will be executed in the same order they are added. sequence_root . addChild ( say_hello ); sequence_root . addChild ( open_gripper ); sequence_root . addChild ( approach_object ); sequence_root . addChild ( close_gripper ); sequence_root . executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */ A dynamically created Tree Give the following XML stored in the file my_tree.xml Note that the following syntax is also valid: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Note You can find more details about the XML schema here . We must first register our custom TreeNodes into the BehaviorTreeFactory and then load the XML from file or text. The identifier used in the XML must coincide with those used to register the TreeNodes. The attribute \"name\" represents the name of the instance and it is optional. #include behaviortree_cpp/xml_parsing.h #include Blackboard/blackboard_local.h #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); // IMPORTANT: when the object tree goes out of scope, // all the TreeNodes instances are destroyed auto tree = buildTreeFromFile ( factory , ./my_tree.xml ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Tutorial 1: Create a Tree"},{"location":"tutorial_A_create_trees/#how-to-create-a-behaviortree","text":"You have mainly two ways to create Behavior Trees. Statically , at compilation time. Dynamically , at run-time, i.e. parsing a file. You are strongly encourage to use the latter approach , but we will describe the former for the sake of completeness.","title":"How to create a BehaviorTree"},{"location":"tutorial_A_create_trees/#how-to-create-your-own-actionnodes","text":"You can find the source code here: sample_nodes/dummy_nodes.h . The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom ActionNodeBase (synchronous Action) class ApproachObject : public BT :: ActionNodeBase { public : ApproachObject ( const std :: string name ) : BT :: ActionNodeBase ( name ) {} // You must override this virtual function BT :: NodeStatus tick () override { std :: cout ApproachObject: this - name () std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // You must override this virtual function virtual void halt () override { // Do nothing. This is used by asynchronous nodes only. } }; As you can see: Any instance of a TreeNode has a name. This identifier is meant to be user-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must return a NodeStatus, i.e. RUNNING, SUCCESS or FAILURE. The method halt() is used to stop an asynchronous Action . ApproachObject doesn't need it. Alternatively, we can use dependecy injection to create a TreeNode given a function pointer. The only requirement of the functor is to have either one of these signatures: BT :: NodeStatus myFunction () BT :: NodeStatus myFunction ( BT :: TreeNode self ) For example: using namespace BT ; NodeStatus SayHello () { std :: cout Robot says Hello std :: endl ; return NodeStatus :: SUCCESS ; } class GripperInterface { public : GripperInterface () : _open ( true ) {} NodeStatus open () { _open = true ; std :: cout GripperInterface::open std :: endl ; return NodeStatus :: SUCCESS ; } NodeStatus close () { std :: cout GripperInterface::close std :: endl ; _open = false ; return NodeStatus :: SUCCESS ; } private : bool _open ; }; We can build a SimpleActionNode from any of these functors: SayHello() GripperInterface::open() GripperInterface::close()","title":"How to create your own ActionNodes"},{"location":"tutorial_A_create_trees/#a-static-tree","text":"Let's create instances of our TreeNodes and compose them into a tree. BT::SequenceNode is a built-in ControlNode provided by the library. BT::SimpleActionNode is a synchronous ActionNode created passing a functor. DummyNodes::ApproachObject is our user-defined ActionNode. #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; SequenceNode sequence_root ( sequence ); SimpleActionNode say_hello ( action_hello , std :: bind ( SayHello ) ); SimpleActionNode open_gripper ( open_gripper , std :: bind ( GripperInterface :: open , gi ) ); SimpleActionNode close_gripper ( close_gripper , std :: bind ( GripperInterface :: close , gi ) ); ApproachObject approach_object ( approach_object ); // Add children to the sequence. // They will be executed in the same order they are added. sequence_root . addChild ( say_hello ); sequence_root . addChild ( open_gripper ); sequence_root . addChild ( approach_object ); sequence_root . addChild ( close_gripper ); sequence_root . executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"A static Tree"},{"location":"tutorial_A_create_trees/#a-dynamically-created-tree","text":"Give the following XML stored in the file my_tree.xml Note that the following syntax is also valid: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Note You can find more details about the XML schema here . We must first register our custom TreeNodes into the BehaviorTreeFactory and then load the XML from file or text. The identifier used in the XML must coincide with those used to register the TreeNodes. The attribute \"name\" represents the name of the instance and it is optional. #include behaviortree_cpp/xml_parsing.h #include Blackboard/blackboard_local.h #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); // IMPORTANT: when the object tree goes out of scope, // all the TreeNodes instances are destroyed auto tree = buildTreeFromFile ( factory , ./my_tree.xml ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"A dynamically created Tree"},{"location":"tutorial_B_node_parameters/","text":"How to use NodeParameters NodeParameters are like arguments passed to a function. They are a map of key/value pairs (both strings) that are usually read from file. To create a TreeNodes that accepts NodeParameters, you must follow these rules: Inherit from either ActionNodeBase, ActionNode, ConditionNode or DecoratorNode. You must provide a constructor with the following signature: MyAction ( const std :: string name , const BT :: NodeParameters params ) The following static member function must be defined: static const BT :: NodeParameters requiredNodeParameters () Alternatively, since version 2.2, Simple Nodes can also support NodeParameters. Check the tutorial 6 for details. Example: an Action requiring the parameter \"message\" SaySomething is a simple synchronous ActionNodeBase which will print the string passed in the NodeParameter called \"message\". Please note: The constructor signature. The static method requiredNodeParameters() contains a single key/value pair. The string \"default message\" is the default value. Parameters must be accessed using the method getParam() , preferably inside the tick() method. class SaySomething : public ActionNodeBase { public : // There must be a constructor with this signature SaySomething ( const std :: string name , const NodeParameters params ) : ActionNodeBase ( name , params ) {} // It is mandatory to define this static method. static const NodeParameters requiredNodeParameters () { static NodeParameters params = {{ message , default message }}; return params ; } virtual NodeStatus tick () override { std :: string msg ; if ( getParam ( message , msg ) == false ) { // if getParam failed, use the default value msg = requiredNodeParameters (). at ( message ); } std :: cout Robot says: msg std :: endl ; return BT :: NodeStatus :: SUCCESS ; } virtual void halt () override {} }; Example: conversion to user defined C++ types In the next example we have a user defined type Pose2D . struct Pose2D { double x , y , theta ; }; If we want the method getParam() to be able to parse a string and store its value into a Pose2D , we must provide our own template specialization of convertFromString T () . In this case, the text representation of a Pose2D is three real numbers separated by semicolons, like this: 1.1;-2.32;0.4 Since this is a common pattern, the library provide the helper function BT::splitString . // use this namespace namespace BT { // This template specialization is needed if you want // to AUTOMATICALLY convert a NodeParameter into a Pose2D template Pose2D BT :: convertFromString ( const StringView key ) { // Three real numbers separated by semicolons. // You may use boost/algorithm/string/split.hpp if you prefer auto parts = BT :: splitString ( key , ; ); if ( parts . size () != 3 ) { throw std :: runtime_error ( invalid input) ); } else { Pose2D output ; output . x = convertFromString double ( parts [ 0 ] ); output . y = convertFromString double ( parts [ 1 ] ); output . theta = convertFromString double ( parts [ 2 ] ); return output ; } } } // end namespace We now define a asynchronous ActionNode called MoveBaseAction . The method tick() of an AsynActionNode is executed in its own thread. The method getParam() will call the function convertFromString Pose2D () under the hood; alternatively, we can use the latter funtion directly, for instance to convert the default string \"0;0;0\" into a Pose2D. // This is an asynchronous operation that will run in a separate thread. // It requires the NodeParameter goal . // If the key is not provided, the default value 0;0;0 is used instead. class MoveBaseAction : public AsynActionNode { public : MoveBaseAction ( const std :: string name , const NodeParameters params ) : AsynActionNode ( name , params ) {} static const BT :: NodeParameters requiredNodeParameters () { static BT :: NodeParameters params = {{ goal , 0;0;0 }}; return params ; } virtual NodeStatus tick () override { Pose2D goal ; if ( getParam Pose2D ( goal , goal ) == false ) { auto default_goal = requiredNodeParameters (). at ( goal ); goal = BT :: convertFromString Pose2D ( default_goal_value ); } printf ( [ MoveBase: STARTED ]. goal: x=%.f y=%.1f theta=%.2f \\n , goal . x , goal . y , goal . theta ); halt_requested_ = false ; int count = 0 ; // compute for 250 milliseconds or until halt_requested_ while ( ! halt_requested_ count ++ 25 ) { SleepMilliseconds ( 10 ); } std :: cout [ MoveBase: FINISHED ] std :: endl ; return halt_requested_ ? NodeStatus :: FAILURE : NodeStatus :: SUCCESS ; } virtual void halt () override { halt_requested_ = true ; } private : bool halt_requested_ ; }; NodeParameters in the XML To pass the parameter from a XML, use attributes: Sequence MoveBaseAction goal= 41.2;13.5;0.7 / SaySomething message= Destination reached / SaySomething/ !-- No parameter passed -- /Sequence Expected output: [ MoveBase: STARTED ]: goal: x=41.2 y=13.5 theta=0.7 [ MoveBase: FINISHED ] Robot says: Destination reached Robot says: default message","title":"Tutorial 2: NodeParameters"},{"location":"tutorial_B_node_parameters/#how-to-use-nodeparameters","text":"NodeParameters are like arguments passed to a function. They are a map of key/value pairs (both strings) that are usually read from file. To create a TreeNodes that accepts NodeParameters, you must follow these rules: Inherit from either ActionNodeBase, ActionNode, ConditionNode or DecoratorNode. You must provide a constructor with the following signature: MyAction ( const std :: string name , const BT :: NodeParameters params ) The following static member function must be defined: static const BT :: NodeParameters requiredNodeParameters () Alternatively, since version 2.2, Simple Nodes can also support NodeParameters. Check the tutorial 6 for details.","title":"How to use NodeParameters"},{"location":"tutorial_B_node_parameters/#example-an-action-requiring-the-parameter-message","text":"SaySomething is a simple synchronous ActionNodeBase which will print the string passed in the NodeParameter called \"message\". Please note: The constructor signature. The static method requiredNodeParameters() contains a single key/value pair. The string \"default message\" is the default value. Parameters must be accessed using the method getParam() , preferably inside the tick() method. class SaySomething : public ActionNodeBase { public : // There must be a constructor with this signature SaySomething ( const std :: string name , const NodeParameters params ) : ActionNodeBase ( name , params ) {} // It is mandatory to define this static method. static const NodeParameters requiredNodeParameters () { static NodeParameters params = {{ message , default message }}; return params ; } virtual NodeStatus tick () override { std :: string msg ; if ( getParam ( message , msg ) == false ) { // if getParam failed, use the default value msg = requiredNodeParameters (). at ( message ); } std :: cout Robot says: msg std :: endl ; return BT :: NodeStatus :: SUCCESS ; } virtual void halt () override {} };","title":"Example: an Action requiring the parameter \"message\""},{"location":"tutorial_B_node_parameters/#example-conversion-to-user-defined-c-types","text":"In the next example we have a user defined type Pose2D . struct Pose2D { double x , y , theta ; }; If we want the method getParam() to be able to parse a string and store its value into a Pose2D , we must provide our own template specialization of convertFromString T () . In this case, the text representation of a Pose2D is three real numbers separated by semicolons, like this: 1.1;-2.32;0.4 Since this is a common pattern, the library provide the helper function BT::splitString . // use this namespace namespace BT { // This template specialization is needed if you want // to AUTOMATICALLY convert a NodeParameter into a Pose2D template Pose2D BT :: convertFromString ( const StringView key ) { // Three real numbers separated by semicolons. // You may use boost/algorithm/string/split.hpp if you prefer auto parts = BT :: splitString ( key , ; ); if ( parts . size () != 3 ) { throw std :: runtime_error ( invalid input) ); } else { Pose2D output ; output . x = convertFromString double ( parts [ 0 ] ); output . y = convertFromString double ( parts [ 1 ] ); output . theta = convertFromString double ( parts [ 2 ] ); return output ; } } } // end namespace We now define a asynchronous ActionNode called MoveBaseAction . The method tick() of an AsynActionNode is executed in its own thread. The method getParam() will call the function convertFromString Pose2D () under the hood; alternatively, we can use the latter funtion directly, for instance to convert the default string \"0;0;0\" into a Pose2D. // This is an asynchronous operation that will run in a separate thread. // It requires the NodeParameter goal . // If the key is not provided, the default value 0;0;0 is used instead. class MoveBaseAction : public AsynActionNode { public : MoveBaseAction ( const std :: string name , const NodeParameters params ) : AsynActionNode ( name , params ) {} static const BT :: NodeParameters requiredNodeParameters () { static BT :: NodeParameters params = {{ goal , 0;0;0 }}; return params ; } virtual NodeStatus tick () override { Pose2D goal ; if ( getParam Pose2D ( goal , goal ) == false ) { auto default_goal = requiredNodeParameters (). at ( goal ); goal = BT :: convertFromString Pose2D ( default_goal_value ); } printf ( [ MoveBase: STARTED ]. goal: x=%.f y=%.1f theta=%.2f \\n , goal . x , goal . y , goal . theta ); halt_requested_ = false ; int count = 0 ; // compute for 250 milliseconds or until halt_requested_ while ( ! halt_requested_ count ++ 25 ) { SleepMilliseconds ( 10 ); } std :: cout [ MoveBase: FINISHED ] std :: endl ; return halt_requested_ ? NodeStatus :: FAILURE : NodeStatus :: SUCCESS ; } virtual void halt () override { halt_requested_ = true ; } private : bool halt_requested_ ; };","title":"Example: conversion to user defined C++ types"},{"location":"tutorial_B_node_parameters/#nodeparameters-in-the-xml","text":"To pass the parameter from a XML, use attributes: Sequence MoveBaseAction goal= 41.2;13.5;0.7 / SaySomething message= Destination reached / SaySomething/ !-- No parameter passed -- /Sequence Expected output: [ MoveBase: STARTED ]: goal: x=41.2 y=13.5 theta=0.7 [ MoveBase: FINISHED ] Robot says: Destination reached Robot says: default message","title":"NodeParameters in the XML"},{"location":"tutorial_C_blackboard/","text":"Blackboards The blackboard is a a key/value storage shared by all the Nodes of a tree. The key is a string whilst the value is a type-erased container (called SafeAny::Any ) that allows the user to store any C++ object and to cast it back to its original form. Contrariwise to boost::any and std::any , SafeAny::Any will also try to avoid common overflow and underflow errors. In fact, you can't cast a negative number into an unsigned integer , nor a very large number that exceeds 2^8 into a char . If the value is stored as a string, the blackboard will use convertFromString T () to cast it to the type T (see previous example ); The user can create his/her own Blackboards backend; it is possible, for instance, to create a persistent blackboard using a database. Assign a blackboard to a tree Let's start with the a SimpleActionNode that writes into the blackboard. // Write into the blackboard key: [GoalPose] // Use this function to create a SimpleActionNode NodeStatus CalculateGoalPose ( TreeNode self ) { const Pose2D mygoal = { 1 , 2 , 3.14 }; // RECOMMENDED: check if the blackboard is nullptr first if ( self . blackboard () ) { // store it in the blackboard self . blackboard () - set ( GoalPose , mygoal ); return NodeStatus :: SUCCESS ; } else { // No blackboard passed to this node. return NodeStatus :: FAILURE ; } } Let's consider the following XML tree definition: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree SequenceStar CalculateGoalPose/ MoveBase goal= ${GoalPose} / SetBlackboard key= OtherGoal value= -1;3;0.5 / MoveBase goal= ${OtherGoal} / /SequenceStar /BehaviorTree /root The root SequenceStar will execute four actions: CalculateGoalPose writes into the blackboard key \"GoalPose\". The syntax ${...} tells to MoveBase to read the goal at run-time from the blackboard; they blackboard key is \"GoalPose\". Alternatively, you can write a key/value pair into the blackboard using the built-in action SetBlackboard . Similar to step 2. Pose2D is retrieved from the key \"OtherGoal\". Note For your information, GoalPose is stored as a type erased Pose2D. On the other hand, OtherGoal is stored as a std::string, but is converted to Pose2D by the method getParam() using the function convertFromString Pose2D () . In the following code sample we can see two equivalent ways to assign a Blackboard to a tree. int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( CalculateGoalPose , CalculateGoalPose ); factory . registerNodeType MoveBaseAction ( MoveBase ); // create a Blackboard from BlackboardLocal (simple, not persistent, local storage) auto blackboard = Blackboard :: create BlackboardLocal (); // Important: when the object tree goes out of scope, all the TreeNodes are destroyed auto tree = buildTreeFromText ( factory , xml_text , blackboard ); // alternatively: // auto tree = buildTreeFromText(factory, xml_text); // assignBlackboardToEntireTree( tree.root_node, blackboard ); NodeStatus status = NodeStatus :: RUNNING ; while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); SleepMS ( 1 ); // optional sleep to avoid busy loops } return 0 ; } /* Expected output [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.14 [ MoveBase: FINISHED ] [ MoveBase: STARTED ]. goal: x=-1 y=3.0 theta=0.50 [ MoveBase: FINISHED ] */","title":"Tutorial 3: Blackboards"},{"location":"tutorial_C_blackboard/#blackboards","text":"The blackboard is a a key/value storage shared by all the Nodes of a tree. The key is a string whilst the value is a type-erased container (called SafeAny::Any ) that allows the user to store any C++ object and to cast it back to its original form. Contrariwise to boost::any and std::any , SafeAny::Any will also try to avoid common overflow and underflow errors. In fact, you can't cast a negative number into an unsigned integer , nor a very large number that exceeds 2^8 into a char . If the value is stored as a string, the blackboard will use convertFromString T () to cast it to the type T (see previous example ); The user can create his/her own Blackboards backend; it is possible, for instance, to create a persistent blackboard using a database.","title":"Blackboards"},{"location":"tutorial_C_blackboard/#assign-a-blackboard-to-a-tree","text":"Let's start with the a SimpleActionNode that writes into the blackboard. // Write into the blackboard key: [GoalPose] // Use this function to create a SimpleActionNode NodeStatus CalculateGoalPose ( TreeNode self ) { const Pose2D mygoal = { 1 , 2 , 3.14 }; // RECOMMENDED: check if the blackboard is nullptr first if ( self . blackboard () ) { // store it in the blackboard self . blackboard () - set ( GoalPose , mygoal ); return NodeStatus :: SUCCESS ; } else { // No blackboard passed to this node. return NodeStatus :: FAILURE ; } } Let's consider the following XML tree definition: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree SequenceStar CalculateGoalPose/ MoveBase goal= ${GoalPose} / SetBlackboard key= OtherGoal value= -1;3;0.5 / MoveBase goal= ${OtherGoal} / /SequenceStar /BehaviorTree /root The root SequenceStar will execute four actions: CalculateGoalPose writes into the blackboard key \"GoalPose\". The syntax ${...} tells to MoveBase to read the goal at run-time from the blackboard; they blackboard key is \"GoalPose\". Alternatively, you can write a key/value pair into the blackboard using the built-in action SetBlackboard . Similar to step 2. Pose2D is retrieved from the key \"OtherGoal\". Note For your information, GoalPose is stored as a type erased Pose2D. On the other hand, OtherGoal is stored as a std::string, but is converted to Pose2D by the method getParam() using the function convertFromString Pose2D () . In the following code sample we can see two equivalent ways to assign a Blackboard to a tree. int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( CalculateGoalPose , CalculateGoalPose ); factory . registerNodeType MoveBaseAction ( MoveBase ); // create a Blackboard from BlackboardLocal (simple, not persistent, local storage) auto blackboard = Blackboard :: create BlackboardLocal (); // Important: when the object tree goes out of scope, all the TreeNodes are destroyed auto tree = buildTreeFromText ( factory , xml_text , blackboard ); // alternatively: // auto tree = buildTreeFromText(factory, xml_text); // assignBlackboardToEntireTree( tree.root_node, blackboard ); NodeStatus status = NodeStatus :: RUNNING ; while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); SleepMS ( 1 ); // optional sleep to avoid busy loops } return 0 ; } /* Expected output [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.14 [ MoveBase: FINISHED ] [ MoveBase: STARTED ]. goal: x=-1 y=3.0 theta=0.50 [ MoveBase: FINISHED ] */","title":"Assign a blackboard to a tree"},{"location":"tutorial_D_subtrees/","text":"One of the main advantages of Behavior Trees is that they are intrinsically hierarchical . You might have noticed that it is always possible to raise the level of abstraction looking one node up in the hierarchy of the tree. In the Introduction we presented this tree: The Sequence called \"Unlock\" can be seen as an entire subtree; from the point of view of its parent, that subtree can have an arbitrary level of complexity. BehaviorTree.CPP provides a way to create reusable and composable Subtrees that can be included as nodes of a larger and more complex tree. Example: subtrees in XML To define and insert a Subtree you don't need to modify your c++ code , nor your existing TreeNodes implementations. Multiple BehaviorTrees can be created and composed in the XML itself. root main_tree_to_execute = MainTree !--------------------------------------- BehaviorTree ID= DoorClosed Sequence name= door_closed_sequence Inverter IsDoorOpen/ /Inverter RetryUntilSuccesful num_attempts= 4 OpenDoor/ /RetryUntilSuccesful PassThroughDoor/ /Sequence /BehaviorTree !--------------------------------------- BehaviorTree ID= MainTree Fallback name= root_Fallback Sequence name= door_open_sequence IsDoorOpen/ PassThroughDoor/ /Sequence SubTree ID= DoorClosed / PassThroughWindow/ /Fallback /BehaviorTree !--------------------------------------- /root The corresponding graphical representation is:","title":"Tutorial 4: Subtrees"},{"location":"tutorial_D_subtrees/#example-subtrees-in-xml","text":"To define and insert a Subtree you don't need to modify your c++ code , nor your existing TreeNodes implementations. Multiple BehaviorTrees can be created and composed in the XML itself. root main_tree_to_execute = MainTree !--------------------------------------- BehaviorTree ID= DoorClosed Sequence name= door_closed_sequence Inverter IsDoorOpen/ /Inverter RetryUntilSuccesful num_attempts= 4 OpenDoor/ /RetryUntilSuccesful PassThroughDoor/ /Sequence /BehaviorTree !--------------------------------------- BehaviorTree ID= MainTree Fallback name= root_Fallback Sequence name= door_open_sequence IsDoorOpen/ PassThroughDoor/ /Sequence SubTree ID= DoorClosed / PassThroughWindow/ /Fallback /BehaviorTree !--------------------------------------- /root The corresponding graphical representation is:","title":"Example: subtrees in XML"},{"location":"tutorial_E_plugins/","text":"Plugins In the previous examples the user-defined nodes where included and linked statically into out C++ projects. We used the BehaviorTreeFactory to registed manualy these custom TreeNodes. Alternatively, we can load user-defined TreeNodes at run-time using pre-compiled dynamic shared libraries, i.e. plugins . Example Let's consider the first tutorial . To create a plugin we must encapsulate the registration of one or multiple TreeNodes into a single function like this: // This is a macro that defines a function with a single argument // (BehaviorTreeFactory factory) BT_REGISTER_NODES ( factory ) { static GripperInterface gi ; // we can t have more than instance factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); factory . registerNodeType SaySomething ( SaySomething ); } Note This function must be placed in .cpp file, not the header file. Here, we assume that BT_REGISTER_NODES and the definitions of our custom TreeNodes are all defined in the file dummy_nodes.cpp . When you use cmake to compile a plugin, add the argument SHARED to add_library . #your CMakeLists.txt add_library ( dummy_nodes SHARED dummy_nodes.cpp ) In Linux, the file libdummy_nodes.so will be created. The first tutorial becomes, as a result, much simpler: #include behaviortree_cpp/xml_parsing.h #include Blackboard/blackboard_local.h // #include dummy_nodes.h YOU DON T NEED THIS ANYMORE using namespace BT ; const std :: string xml_text = R ( root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root ) ; int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerFromPlugin ( ./libdummy_nodes.so ); auto tree = buildTreeFromText ( factory , xml_text ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */ Display the manifest of a plugin BehaviorTree.CPP provides a command line tool called bt_plugin_manifest . It shows all user-defind TreeNodes registered into the plugin and their corresponding NodeParameters. $ ./bt_plugin_manifest ./libdummy_nodes.so --------------- ApproachObject [Action] NodeParameters: 0 --------------- CloseGripper [Action] NodeParameters: 0 --------------- OpenGripper [Action] NodeParameters: 0 --------------- SayHello [Action] NodeParameters: 0 --------------- SaySomething [Action] NodeParameters: 1: - [Key]: message / [Default]:","title":"Tutorial 5: Plugins"},{"location":"tutorial_E_plugins/#plugins","text":"In the previous examples the user-defined nodes where included and linked statically into out C++ projects. We used the BehaviorTreeFactory to registed manualy these custom TreeNodes. Alternatively, we can load user-defined TreeNodes at run-time using pre-compiled dynamic shared libraries, i.e. plugins .","title":"Plugins"},{"location":"tutorial_E_plugins/#example","text":"Let's consider the first tutorial . To create a plugin we must encapsulate the registration of one or multiple TreeNodes into a single function like this: // This is a macro that defines a function with a single argument // (BehaviorTreeFactory factory) BT_REGISTER_NODES ( factory ) { static GripperInterface gi ; // we can t have more than instance factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); factory . registerNodeType SaySomething ( SaySomething ); } Note This function must be placed in .cpp file, not the header file. Here, we assume that BT_REGISTER_NODES and the definitions of our custom TreeNodes are all defined in the file dummy_nodes.cpp . When you use cmake to compile a plugin, add the argument SHARED to add_library . #your CMakeLists.txt add_library ( dummy_nodes SHARED dummy_nodes.cpp ) In Linux, the file libdummy_nodes.so will be created. The first tutorial becomes, as a result, much simpler: #include behaviortree_cpp/xml_parsing.h #include Blackboard/blackboard_local.h // #include dummy_nodes.h YOU DON T NEED THIS ANYMORE using namespace BT ; const std :: string xml_text = R ( root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root ) ; int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerFromPlugin ( ./libdummy_nodes.so ); auto tree = buildTreeFromText ( factory , xml_text ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Example"},{"location":"tutorial_E_plugins/#display-the-manifest-of-a-plugin","text":"BehaviorTree.CPP provides a command line tool called bt_plugin_manifest . It shows all user-defind TreeNodes registered into the plugin and their corresponding NodeParameters. $ ./bt_plugin_manifest ./libdummy_nodes.so --------------- ApproachObject [Action] NodeParameters: 0 --------------- CloseGripper [Action] NodeParameters: 0 --------------- OpenGripper [Action] NodeParameters: 0 --------------- SayHello [Action] NodeParameters: 0 --------------- SaySomething [Action] NodeParameters: 1: - [Key]: message / [Default]:","title":"Display the manifest of a plugin"},{"location":"tutorial_F_loggers/","text":"BehaviorTree.CPP provides an extensible set of Loggers, i.e. a mechanism to record and/or display all the state transitions in out tree. Example We can attach multiple loggers to a tree. To do this, we pass the root of the tree. #include behaviortree_cpp/xml_parsing.h #include behaviortree_cpp/loggers/bt_cout_logger.h #include behaviortree_cpp/loggers/bt_minitrace_logger.h #include behaviortree_cpp/loggers/bt_file_logger.h #ifdef ZMQ_FOUND #include behaviortree_cpp/loggers/bt_zmq_publisher.h #endif using namespace BT ; int main () { BT :: BehaviorTreeFactory factory ; // Load and register all the Custom TreeNodes from plugin factory . registerFromPlugin ( ./libcrossdoor_nodes.so ); auto tree = buildTreeFromFile ( factory , crossdoor.xml ); // Create some loggers. StdCoutLogger logger_cout ( tree . root_node ); FileLogger logger_file ( tree . root_node , bt_trace.fbl ); MinitraceLogger logger_minitrace ( tree . root_node , bt_trace.json ); #ifdef ZMQ_FOUND PublisherZMQ publisher_zmq ( tree . root_node ); #endif // Keep on ticking until you get either a SUCCESS or FAILURE NodeStatus status = NodeStatus :: RUNNING ; while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); CrossDoor :: SleepMS ( 1 ); // optional sleep to avoid busy loops } return 0 ; } StdCoutLogger It simply prints the state transition on std::cout . FileLogger It stores the state transitions (and their timestamp) in the binary file called \"bt_trace.fbl\". To visualize the content of this file, use the command line tool bt_log_cat . MinitraceLogger This logger stores the states trnasitions and durations in a JSON file format. Its goal is to show the time required by a TreeNode to complete its tick() operation. This tracing format can be visualized in the Chrome tracer viewer; you can access it typing this in the address bar: chrome://tracing . For more information, refer to: MiniTrace (GitHub) PublisherZMQ It publishes state transitions in real-time using ZMQ . You can record them using the command line tool bt_recorder .","title":"Tutorial 6: Loggers"},{"location":"tutorial_F_loggers/#example","text":"We can attach multiple loggers to a tree. To do this, we pass the root of the tree. #include behaviortree_cpp/xml_parsing.h #include behaviortree_cpp/loggers/bt_cout_logger.h #include behaviortree_cpp/loggers/bt_minitrace_logger.h #include behaviortree_cpp/loggers/bt_file_logger.h #ifdef ZMQ_FOUND #include behaviortree_cpp/loggers/bt_zmq_publisher.h #endif using namespace BT ; int main () { BT :: BehaviorTreeFactory factory ; // Load and register all the Custom TreeNodes from plugin factory . registerFromPlugin ( ./libcrossdoor_nodes.so ); auto tree = buildTreeFromFile ( factory , crossdoor.xml ); // Create some loggers. StdCoutLogger logger_cout ( tree . root_node ); FileLogger logger_file ( tree . root_node , bt_trace.fbl ); MinitraceLogger logger_minitrace ( tree . root_node , bt_trace.json ); #ifdef ZMQ_FOUND PublisherZMQ publisher_zmq ( tree . root_node ); #endif // Keep on ticking until you get either a SUCCESS or FAILURE NodeStatus status = NodeStatus :: RUNNING ; while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); CrossDoor :: SleepMS ( 1 ); // optional sleep to avoid busy loops } return 0 ; }","title":"Example"},{"location":"tutorial_F_loggers/#stdcoutlogger","text":"It simply prints the state transition on std::cout .","title":"StdCoutLogger"},{"location":"tutorial_F_loggers/#filelogger","text":"It stores the state transitions (and their timestamp) in the binary file called \"bt_trace.fbl\". To visualize the content of this file, use the command line tool bt_log_cat .","title":"FileLogger"},{"location":"tutorial_F_loggers/#minitracelogger","text":"This logger stores the states trnasitions and durations in a JSON file format. Its goal is to show the time required by a TreeNode to complete its tick() operation. This tracing format can be visualized in the Chrome tracer viewer; you can access it typing this in the address bar: chrome://tracing . For more information, refer to: MiniTrace (GitHub)","title":"MinitraceLogger"},{"location":"tutorial_F_loggers/#publisherzmq","text":"It publishes state transitions in real-time using ZMQ . You can record them using the command line tool bt_recorder .","title":"PublisherZMQ"},{"location":"tutorial_G_legacy/","text":"Wrap legacy code In this tutorial we see how to deal with legacy code that was not meant to be used with BehaviorTree.CPP. Let's start supposing that this is my class. // This is my custom type. struct Point3D { double x , y , z ; }; class MyLegacyMoveTo { public : bool go ( Point3D goal ) { printf ( Going to: %f %f %f \\n , goal . x , goal . y , goal . z ); return true ; // true means success in my legacy code } }; We want to create an ActionNode called \"MoveTo\" that invokes the method MyLegacyMoveTo::go() . The final goal is to be able to use this ActionNode in a tree like this one: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree SequenceStar name= root MoveTo goal= -1;3;0.5 / MoveTo goal= ${myGoal} / /SequenceStar /BehaviorTree /root The first thing that we need to do is to allow our library to convert a NodeParameter (that is nothing more than a pair of strings representing key/value) into a Point3D. As we did in a previous tutorial, we should implement a template specialization for convertFromString . Our particular string representation of a Point3D consists in three semicolon-separated numbers, representing __x, y and z_. namespace BT { template Point3D convertFromString ( const StringView key ) { // three real numbers separated by semicolons auto parts = BT :: splitString ( key , ; ); if ( parts . size () != 3 ) { throw std :: runtime_error ( invalid input) ); } else { Point3D output ; output . x = convertFromString double ( parts [ 0 ]); output . y = convertFromString double ( parts [ 1 ]); output . z = convertFromString double ( parts [ 2 ]); return output ; } } } Finally, we can use a C++11 lambda (or, alternatively, std::bind ) to wrap out method into a function with the right signature. int main () { using namespace BT ; MyLegacyMoveTo move_to ; // Here we use a lambda that captures the reference of move_to auto MoveToWrapperWithLambda = [ move_to ]( TreeNode parent_node ) - NodeStatus { Point3D goal ; // thanks to paren_node, you can access easily the NodeParameters and the blackboard parent_node . getParam ( goal , goal ); bool res = move_to . go ( goal ); // convert bool to NodeStatus return res ? NodeStatus :: SUCCESS : NodeStatus :: FAILURE ; }; BehaviorTreeFactory factory ; factory . registerSimpleAction ( MoveTo , MoveToWrapperWithLambda ); auto blackboard = Blackboard :: create BlackboardLocal (); auto tree = buildTreeFromText ( factory , xml_text , blackboard ); // We set the entry myGoal in the blackboard. Point3D my_goal = { 3 , 4 , 5 }; blackboard - set ( myGoal , my_goal ); NodeStatus status = NodeStatus :: RUNNING ; while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); } return 0 ; } /* Expected output: Going to: -1.000000 3.000000 0.500000 Going to: 3.000000 4.000000 5.000000 The first MoveTo read the parameter from the string -1;3;0.5 whilst the second from the blackboard, that contains a copy of the Point3D my_goal. */ The functor we are passing to SimpleActionNode requires the following signature: BT::NodeStatus myFunction(BT::TreeNode parent) As a consequence, we can access a NodeParameter by parent.getParam() or even set/get an entry of the Blackboard using parent.blackboard()","title":"Tutorial 7: Wrap legacy code"},{"location":"tutorial_G_legacy/#wrap-legacy-code","text":"In this tutorial we see how to deal with legacy code that was not meant to be used with BehaviorTree.CPP. Let's start supposing that this is my class. // This is my custom type. struct Point3D { double x , y , z ; }; class MyLegacyMoveTo { public : bool go ( Point3D goal ) { printf ( Going to: %f %f %f \\n , goal . x , goal . y , goal . z ); return true ; // true means success in my legacy code } }; We want to create an ActionNode called \"MoveTo\" that invokes the method MyLegacyMoveTo::go() . The final goal is to be able to use this ActionNode in a tree like this one: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree SequenceStar name= root MoveTo goal= -1;3;0.5 / MoveTo goal= ${myGoal} / /SequenceStar /BehaviorTree /root The first thing that we need to do is to allow our library to convert a NodeParameter (that is nothing more than a pair of strings representing key/value) into a Point3D. As we did in a previous tutorial, we should implement a template specialization for convertFromString . Our particular string representation of a Point3D consists in three semicolon-separated numbers, representing __x, y and z_. namespace BT { template Point3D convertFromString ( const StringView key ) { // three real numbers separated by semicolons auto parts = BT :: splitString ( key , ; ); if ( parts . size () != 3 ) { throw std :: runtime_error ( invalid input) ); } else { Point3D output ; output . x = convertFromString double ( parts [ 0 ]); output . y = convertFromString double ( parts [ 1 ]); output . z = convertFromString double ( parts [ 2 ]); return output ; } } } Finally, we can use a C++11 lambda (or, alternatively, std::bind ) to wrap out method into a function with the right signature. int main () { using namespace BT ; MyLegacyMoveTo move_to ; // Here we use a lambda that captures the reference of move_to auto MoveToWrapperWithLambda = [ move_to ]( TreeNode parent_node ) - NodeStatus { Point3D goal ; // thanks to paren_node, you can access easily the NodeParameters and the blackboard parent_node . getParam ( goal , goal ); bool res = move_to . go ( goal ); // convert bool to NodeStatus return res ? NodeStatus :: SUCCESS : NodeStatus :: FAILURE ; }; BehaviorTreeFactory factory ; factory . registerSimpleAction ( MoveTo , MoveToWrapperWithLambda ); auto blackboard = Blackboard :: create BlackboardLocal (); auto tree = buildTreeFromText ( factory , xml_text , blackboard ); // We set the entry myGoal in the blackboard. Point3D my_goal = { 3 , 4 , 5 }; blackboard - set ( myGoal , my_goal ); NodeStatus status = NodeStatus :: RUNNING ; while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); } return 0 ; } /* Expected output: Going to: -1.000000 3.000000 0.500000 Going to: 3.000000 4.000000 5.000000 The first MoveTo read the parameter from the string -1;3;0.5 whilst the second from the blackboard, that contains a copy of the Point3D my_goal. */ The functor we are passing to SimpleActionNode requires the following signature: BT::NodeStatus myFunction(BT::TreeNode parent) As a consequence, we can access a NodeParameter by parent.getParam() or even set/get an entry of the Blackboard using parent.blackboard()","title":"Wrap legacy code"},{"location":"tutorial_H_coroutines/","text":"Async Actions using Coroutines BehaviorTree.CPP provides two easy-to-use abstractions to create an asynchronous Action, i.e those actions which: Take a long time to be concluded. May return \"RUNNING\". Can be halted . The first class is AsyncActionNode , that execute the tick() method in a separate thread. In this tutorial we present CoroActionNode , a different class that uses coroutines to achieve a similar results. Coroutines do not spawn a new thread and are much more efficient. The user should explicitly call a yield method where he wants to execution of the Action to be suspended. In this tutorial we will see how it works with a very simple example that you can use as template of your own implementation. class MyAsyncAction : public CoroActionNode { public : MyAsyncAction ( const std :: string name ) : CoroActionNode ( name , NodeParameters ()) {} // This is the ideal skeleton/template of an async action: // - A request to a remote service provider. // - A loop where we check if the reply has been received. // Call setStatusRunningAndYield() to pause . // - Code to execute after the reply. // - a simple way to handle halt(). NodeStatus tick () override { std :: cout name () : Started. Send Request to server. std :: endl ; int cycle = 0 ; bool reply_received = false ; while ( ! reply_received ) { std :: cout name () : Waiting reply. std :: endl ; reply_received = ++ cycle = 3 ; if ( ! reply_received ) { // set status to RUNNING and pause/sleep // If halt() is called, we will not resume execution setStatusRunningAndYield (); } } // this part of the code is never reached if halt() is invoked. std :: cout name () : Done. std :: endl ; return NodeStatus :: SUCCESS ; } void halt () override { std :: cout name () : Halted. Do your cleanup here. std :: endl ; // Do not forget to call this at the end. CoroActionNode :: halt (); } }; To keep the rest of the example simple, we use create a trivial tree with two actions executed in sequence, using the programmatic approach. int main () { // Simple tree: a sequence of two asycnhronous actions BT :: SequenceNode sequence_root ( sequence ); MyAsyncAction action_A ( actionA ); MyAsyncAction action_B ( actionB ); // Add children to the sequence. sequence_root . addChild ( action_A ); sequence_root . addChild ( action_B ); NodeStatus status = NodeStatus :: IDLE ; while ( status != NodeStatus :: SUCCESS status != NodeStatus :: FAILURE ) { status = sequence_root . executeTick (); // It is often a good idea to add a sleep here to avoid busy loops std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 1 ) ); } return 0 ; } /* Expected output: actionA: Started. Send Request to server. actionA: Waiting reply. actionA: Waiting reply. actionA: Waiting reply. actionA: Done. actionB: Started. Send Request to server. actionB: Waiting reply. actionB: Waiting reply. actionB: Waiting reply. actionB: Done. */","title":"Tutorial 8: Actions and Coroutines"},{"location":"tutorial_H_coroutines/#async-actions-using-coroutines","text":"BehaviorTree.CPP provides two easy-to-use abstractions to create an asynchronous Action, i.e those actions which: Take a long time to be concluded. May return \"RUNNING\". Can be halted . The first class is AsyncActionNode , that execute the tick() method in a separate thread. In this tutorial we present CoroActionNode , a different class that uses coroutines to achieve a similar results. Coroutines do not spawn a new thread and are much more efficient. The user should explicitly call a yield method where he wants to execution of the Action to be suspended. In this tutorial we will see how it works with a very simple example that you can use as template of your own implementation. class MyAsyncAction : public CoroActionNode { public : MyAsyncAction ( const std :: string name ) : CoroActionNode ( name , NodeParameters ()) {} // This is the ideal skeleton/template of an async action: // - A request to a remote service provider. // - A loop where we check if the reply has been received. // Call setStatusRunningAndYield() to pause . // - Code to execute after the reply. // - a simple way to handle halt(). NodeStatus tick () override { std :: cout name () : Started. Send Request to server. std :: endl ; int cycle = 0 ; bool reply_received = false ; while ( ! reply_received ) { std :: cout name () : Waiting reply. std :: endl ; reply_received = ++ cycle = 3 ; if ( ! reply_received ) { // set status to RUNNING and pause/sleep // If halt() is called, we will not resume execution setStatusRunningAndYield (); } } // this part of the code is never reached if halt() is invoked. std :: cout name () : Done. std :: endl ; return NodeStatus :: SUCCESS ; } void halt () override { std :: cout name () : Halted. Do your cleanup here. std :: endl ; // Do not forget to call this at the end. CoroActionNode :: halt (); } }; To keep the rest of the example simple, we use create a trivial tree with two actions executed in sequence, using the programmatic approach. int main () { // Simple tree: a sequence of two asycnhronous actions BT :: SequenceNode sequence_root ( sequence ); MyAsyncAction action_A ( actionA ); MyAsyncAction action_B ( actionB ); // Add children to the sequence. sequence_root . addChild ( action_A ); sequence_root . addChild ( action_B ); NodeStatus status = NodeStatus :: IDLE ; while ( status != NodeStatus :: SUCCESS status != NodeStatus :: FAILURE ) { status = sequence_root . executeTick (); // It is often a good idea to add a sleep here to avoid busy loops std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 1 ) ); } return 0 ; } /* Expected output: actionA: Started. Send Request to server. actionA: Waiting reply. actionA: Waiting reply. actionA: Waiting reply. actionA: Done. actionB: Started. Send Request to server. actionB: Waiting reply. actionB: Waiting reply. actionB: Waiting reply. actionB: Done. */","title":"Async Actions using Coroutines"},{"location":"xml_format/","text":"Basics of the XML schema In the first tutorial this simple tree was presented. root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething name= action_hello message= Hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root You may notice that: The first tag of the tree is root . It should contain 1 or more tags BehaviorTree . The tag BehaviorTree should have the attribute [ID] . The tag root should contain the attribute [main_tree_to_execute] ,refering the ID of the main tree. The attribute [main_tree_to_execute] is mandatory if the file contains multiple BehaviorTree , optional otherwise. Each TreeNode is represented by a single tag. In particular: The name of the tag is the ID used to register the TreeNode in the factory. The attribute [name] refers to the name of the instance and is optional . Nodeparameters are passed as attribute as well. In the previous example, the action SaySomething requires the NodeParameter message . In terms of number of children: ControlNodes contain 1 to N children . DecoratorNodes and Subtrees contain only 1 child . ActionNodes and ConditionNodes have no child . Compact vs Explicit representation The following two syntaxes are both valid: SaySomething name= action_hello message= Hello World / Action ID= SaySomething name= action_hello message= Hello World / We will call the former syntax \" compact \" and the latter \" explicit \". The first example represented with the explicit syntax would become: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence Action ID= SaySomething name= action_hello message= Hello / Action ID= OpenGripper name= open_gripper / Action ID= ApproachObject name= approach_object / Action ID= CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Even if the compact syntax is more convenient and easier to write, it provides too little information about the model of the TreeNode. Tools like Groot require either the explicit syntax or additional information. This information can be added using the tag TreeNodeModel . To make the compact version of our tree compatible with Groot, the XML must be modified as follows: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething name= action_hello message= Hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree !-- the BT executor don t require this, but Groot does -- TreeNodeModel Action ID= SaySomething message= default message / Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /TreeNodeModel /root Subtrees As we saw in this tutorial , it is possible to include a Subtree inside another tree to avoid \"copy and pasting\" the same tree in multiple location and to reduce complexity. Let's say that we want to incapsulate few action into the behaviorTree \" GraspObject \" (being optional, attributes [name] are omitted for simplicity). root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence Action ID= SaySomething message= Hello World / Subtree ID= GraspObject / /Sequence /BehaviorTree BehaviorTree ID= GraspObject Sequence Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /Sequence /BehaviorTree /root We may notice as the entire tree \"GraspObject\" is executed after \"SaySomething\". Include external files Since version 2.4 . You can include external files in a way that is similar to #include in C++. We can do this easily using the tag: include path= relative_or_absolute_path_to_file using the previous example, we may split the two behavior trees into two files: !-- file maintree.xml -- root main_tree_to_execute = MainTree include path= grasp.xml / BehaviorTree ID= MainTree Sequence Action ID= SaySomething message= Hello World / Subtree ID= GraspObject / /Sequence /BehaviorTree /root !-- file grasp.xml -- root main_tree_to_execute = GraspObject BehaviorTree ID= GraspObject Sequence Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /Sequence /BehaviorTree /root Note for ROS users If you want to find a file inside a ROS package , you can use this syntax: include ros_pkg=\"name_package\" path=\"path_relative_to_pkg/grasp.xml\"/","title":"The XML format"},{"location":"xml_format/#basics-of-the-xml-schema","text":"In the first tutorial this simple tree was presented. root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething name= action_hello message= Hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root You may notice that: The first tag of the tree is root . It should contain 1 or more tags BehaviorTree . The tag BehaviorTree should have the attribute [ID] . The tag root should contain the attribute [main_tree_to_execute] ,refering the ID of the main tree. The attribute [main_tree_to_execute] is mandatory if the file contains multiple BehaviorTree , optional otherwise. Each TreeNode is represented by a single tag. In particular: The name of the tag is the ID used to register the TreeNode in the factory. The attribute [name] refers to the name of the instance and is optional . Nodeparameters are passed as attribute as well. In the previous example, the action SaySomething requires the NodeParameter message . In terms of number of children: ControlNodes contain 1 to N children . DecoratorNodes and Subtrees contain only 1 child . ActionNodes and ConditionNodes have no child .","title":"Basics of the XML schema"},{"location":"xml_format/#compact-vs-explicit-representation","text":"The following two syntaxes are both valid: SaySomething name= action_hello message= Hello World / Action ID= SaySomething name= action_hello message= Hello World / We will call the former syntax \" compact \" and the latter \" explicit \". The first example represented with the explicit syntax would become: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence Action ID= SaySomething name= action_hello message= Hello / Action ID= OpenGripper name= open_gripper / Action ID= ApproachObject name= approach_object / Action ID= CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Even if the compact syntax is more convenient and easier to write, it provides too little information about the model of the TreeNode. Tools like Groot require either the explicit syntax or additional information. This information can be added using the tag TreeNodeModel . To make the compact version of our tree compatible with Groot, the XML must be modified as follows: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething name= action_hello message= Hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree !-- the BT executor don t require this, but Groot does -- TreeNodeModel Action ID= SaySomething message= default message / Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /TreeNodeModel /root","title":"Compact vs Explicit representation"},{"location":"xml_format/#subtrees","text":"As we saw in this tutorial , it is possible to include a Subtree inside another tree to avoid \"copy and pasting\" the same tree in multiple location and to reduce complexity. Let's say that we want to incapsulate few action into the behaviorTree \" GraspObject \" (being optional, attributes [name] are omitted for simplicity). root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence Action ID= SaySomething message= Hello World / Subtree ID= GraspObject / /Sequence /BehaviorTree BehaviorTree ID= GraspObject Sequence Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /Sequence /BehaviorTree /root We may notice as the entire tree \"GraspObject\" is executed after \"SaySomething\".","title":"Subtrees"},{"location":"xml_format/#include-external-files","text":"Since version 2.4 . You can include external files in a way that is similar to #include in C++. We can do this easily using the tag: include path= relative_or_absolute_path_to_file using the previous example, we may split the two behavior trees into two files: !-- file maintree.xml -- root main_tree_to_execute = MainTree include path= grasp.xml / BehaviorTree ID= MainTree Sequence Action ID= SaySomething message= Hello World / Subtree ID= GraspObject / /Sequence /BehaviorTree /root !-- file grasp.xml -- root main_tree_to_execute = GraspObject BehaviorTree ID= GraspObject Sequence Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /Sequence /BehaviorTree /root Note for ROS users If you want to find a file inside a ROS package , you can use this syntax: include ros_pkg=\"name_package\" path=\"path_relative_to_pkg/grasp.xml\"/","title":"Include external files"}]}