{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home About this library This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions. The problem Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Base Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently ,the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry. What is a Behavior Tree? A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#about-this-library","text":"This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions.","title":"About this library"},{"location":"#the-problem","text":"Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Base Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently ,the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"The problem"},{"location":"#what-is-a-behavior-tree","text":"A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"What is a Behavior Tree?"},{"location":"BT_basics/","text":"Introduction to BTs Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, ie.e the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that triggers an action. The other nodes of the tree, those which are not leaves, control the \"flow of execution\". To better understand how this flow takes place , imagine a signal, that we will further call \" tick \" that is executed at the root of the tree and propagates through the branches until it reaches one or multiple leaves. The result of a tick can be either: SUCCESS FAILURE RUNNING The first two, as their names suggest, inform their parent that their operation was a success or a failure. RUNNING is returned by asynchronous nodes when their execution is not completed and they needs more time to return a valid result. This C++ library provides also the status IDLE ; it means that the node is ready to start. The result of a node is propagated back to the parent, that will decide which child should be ticked next or will return a result to its own parent. Types of nodes ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes is similar to the ControlNode, but it can have only a single child. ActionNodes are leaves and do not have children. The user should implement their own ActionNodes to perform the actual task. ConditionNodes are equivalent to ActionNodes, but they are always atomic, i.e. they must not return RUNNING. They should not alter the state of the system. Learn by example To better understand how a BehaviorTrees work, let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously. Sequence Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . The children of a ControlNode are always ordered ; it is up to the ControlNode to consider this order or not. In the graphical representation, the order of execution is from left to right . In short: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Sequence returns SUCCESS too. Exercise: find the bug! Expand to read the answer. If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseDoor is skipped. Decorators The goal of a DecoratorNode is either to transform the result it received from the child, to terminate the child, or repeat ticking of the child, depending on the type of Decorator. You can create your own Decorators. The node Negation is a Decorator that inverts the result returned by its child; Negation followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But there is an error. Can you find it? Exercise: find the bug! Expand to read the answer. If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. Fallback FallbackNodes , known also as \"Selector\" , are nodes that can express, as the name suggests, fallback strategies, ie. what to do next if a child returns FAILURE. In short, it ticks the children in order and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequence and Fallbacks can be combined: In the door open? I not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room. \"Fetch me a beer\" revisited We can now improve the \"Fetch Me a Beer\" example, which leaves the door open if the beer was not there. We use the color \"green\" to represent nodes which will return SUCCESS and \"red\" for those which return FAILURE. Black nodes are never executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both the trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS if we managed to open and close the fridge. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. Everything works as expected if GrabBeer returns SUCCESS.","title":"The Basics"},{"location":"BT_basics/#introduction-to-bts","text":"Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, ie.e the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that triggers an action. The other nodes of the tree, those which are not leaves, control the \"flow of execution\". To better understand how this flow takes place , imagine a signal, that we will further call \" tick \" that is executed at the root of the tree and propagates through the branches until it reaches one or multiple leaves. The result of a tick can be either: SUCCESS FAILURE RUNNING The first two, as their names suggest, inform their parent that their operation was a success or a failure. RUNNING is returned by asynchronous nodes when their execution is not completed and they needs more time to return a valid result. This C++ library provides also the status IDLE ; it means that the node is ready to start. The result of a node is propagated back to the parent, that will decide which child should be ticked next or will return a result to its own parent.","title":"Introduction to BTs"},{"location":"BT_basics/#types-of-nodes","text":"ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes is similar to the ControlNode, but it can have only a single child. ActionNodes are leaves and do not have children. The user should implement their own ActionNodes to perform the actual task. ConditionNodes are equivalent to ActionNodes, but they are always atomic, i.e. they must not return RUNNING. They should not alter the state of the system.","title":"Types of nodes"},{"location":"BT_basics/#learn-by-example","text":"To better understand how a BehaviorTrees work, let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously.","title":"Learn by example"},{"location":"BT_basics/#sequence","text":"Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . The children of a ControlNode are always ordered ; it is up to the ControlNode to consider this order or not. In the graphical representation, the order of execution is from left to right . In short: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Sequence returns SUCCESS too. Exercise: find the bug! Expand to read the answer. If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseDoor is skipped.","title":"Sequence"},{"location":"BT_basics/#decorators","text":"The goal of a DecoratorNode is either to transform the result it received from the child, to terminate the child, or repeat ticking of the child, depending on the type of Decorator. You can create your own Decorators. The node Negation is a Decorator that inverts the result returned by its child; Negation followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But there is an error. Can you find it? Exercise: find the bug! Expand to read the answer. If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted.","title":"Decorators"},{"location":"BT_basics/#fallback","text":"FallbackNodes , known also as \"Selector\" , are nodes that can express, as the name suggests, fallback strategies, ie. what to do next if a child returns FAILURE. In short, it ticks the children in order and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequence and Fallbacks can be combined: In the door open? I not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room.","title":"Fallback"},{"location":"BT_basics/#fetch-me-a-beer-revisited","text":"We can now improve the \"Fetch Me a Beer\" example, which leaves the door open if the beer was not there. We use the color \"green\" to represent nodes which will return SUCCESS and \"red\" for those which return FAILURE. Black nodes are never executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both the trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS if we managed to open and close the fridge. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. Everything works as expected if GrabBeer returns SUCCESS.","title":"\"Fetch me a beer\" revisited"},{"location":"BlackBoard/","text":"","title":"BlackBoard"},{"location":"DecoratorNode/","text":"Decorators A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked. NegationNode Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too. ForceSuccessNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS. ForceFailureNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE. RepeatNode Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too. RetryNode Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"Decorators Nodes"},{"location":"DecoratorNode/#decorators","text":"A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked.","title":"Decorators"},{"location":"DecoratorNode/#negationnode","text":"Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too.","title":"NegationNode"},{"location":"DecoratorNode/#forcesuccessnode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS.","title":"ForceSuccessNode"},{"location":"DecoratorNode/#forcefailurenode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE.","title":"ForceFailureNode"},{"location":"DecoratorNode/#repeatnode","text":"Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too.","title":"RepeatNode"},{"location":"DecoratorNode/#retrynode","text":"Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"RetryNode"},{"location":"FallbackNode/","text":"Fallback This family of nodes are known as \"Selector\" or, sometimes, \"Priority\" in other frameworks. Its purpose is to try different strategies, until we find one that \"works\". Currently the framework provides two kinds of nodes: FallbackNode FallbackStarNode They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns FAILURE , it ticks the next child. If the last child returns FAILURE too, all the children are halted and the sequence returns FAILURE . If a child returns SUCCESS , it stops and returns SUCCESS . All the children are halted. FallbackNode If a child returns RUNNING : FallbackNode returns RUNNING . The loop is restarted and all the previous children are ticked again unless they are ActionNodes . Example : Try different strategies to open the door. Check first if the door is open. See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // index is reset and children are halted. HaltAllChildren (); return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. HaltAllChildren (); return FAILURE ; FallbackStarNode If a child returns RUNNING : FallbackStarNode returns RUNNING . The loop is not restarted and none of the previous children is ticked. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // At the next tick, index will be the same. HaltAllChildren (); index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ;","title":"Fallback Nodes"},{"location":"FallbackNode/#fallback","text":"This family of nodes are known as \"Selector\" or, sometimes, \"Priority\" in other frameworks. Its purpose is to try different strategies, until we find one that \"works\". Currently the framework provides two kinds of nodes: FallbackNode FallbackStarNode They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns FAILURE , it ticks the next child. If the last child returns FAILURE too, all the children are halted and the sequence returns FAILURE . If a child returns SUCCESS , it stops and returns SUCCESS . All the children are halted.","title":"Fallback"},{"location":"FallbackNode/#fallbacknode","text":"If a child returns RUNNING : FallbackNode returns RUNNING . The loop is restarted and all the previous children are ticked again unless they are ActionNodes . Example : Try different strategies to open the door. Check first if the door is open. See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // index is reset and children are halted. HaltAllChildren (); return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. HaltAllChildren (); return FAILURE ;","title":"FallbackNode"},{"location":"FallbackNode/#fallbackstarnode","text":"If a child returns RUNNING : FallbackStarNode returns RUNNING . The loop is not restarted and none of the previous children is ticked. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // At the next tick, index will be the same. HaltAllChildren (); index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ;","title":"FallbackStarNode"},{"location":"NodeParameters/","text":"NodeParameters","title":"NodeParameters"},{"location":"NodeParameters/#nodeparameters","text":"","title":"NodeParameters"},{"location":"SequenceNode/","text":"Sequences A Sequence ticks all it's children as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Currently the framework provides two kinds of nodes: SequenceNode SequenceStarNode They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . SequenceNode If a child returns FAILURE, the sequence returns FAILURE. The index is reset and all the children are halted. If a child returns RUNNING: the sequence returns RUNNING. the loop is restarted and all the previous children are ticked again unless they are ActionNodes . Example : This tree represents the behavior of a sniper in a computer game. If any of these conditions/actions fails, the entire sequence is executed again from the beginning. A running actions will be interrupted if isEnemyVisible becomes false (i.e. it returns FAILURE). See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // Suspend execution and return FAILURE. // index is reset and children are halted. HaltAllChildren (); return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); return SUCCESS ; SequenceStarNode Use this ControlNode when you don't want to tick a child more than once. You can customize its behavior using the NodeParameter \"reset_on_failure\". If a child returns FAILURE, the sequence returns FAILURE. [reset_on_failure = \"true\"]: (default) the loop is restarted. [reset_on_failure = \"false\"]: the same failed child is executed again. If a child returns RUNNING, the sequence returns RUNNING. The same child will be ticked again. Example : This is a patrolling agent/robot that must visit locations A, B and C only once . If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK must be checked at every tick, for this reason its parent must be a SequenceNode. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_status == FAILURE ) { // Suspend execution and return FAILURE. // At the next tick, index will be the same. if ( reset_on_failure ) { HaltAllChildren (); index = 0 ; } return FAILURE ; } } // all the children returned success. Return SUCCESS too. index = 0 ; HaltAllChildren (); return SUCCESS ;","title":"Sequence Nodes"},{"location":"SequenceNode/#sequences","text":"A Sequence ticks all it's children as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Currently the framework provides two kinds of nodes: SequenceNode SequenceStarNode They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS .","title":"Sequences"},{"location":"SequenceNode/#sequencenode","text":"If a child returns FAILURE, the sequence returns FAILURE. The index is reset and all the children are halted. If a child returns RUNNING: the sequence returns RUNNING. the loop is restarted and all the previous children are ticked again unless they are ActionNodes . Example : This tree represents the behavior of a sniper in a computer game. If any of these conditions/actions fails, the entire sequence is executed again from the beginning. A running actions will be interrupted if isEnemyVisible becomes false (i.e. it returns FAILURE). See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // Suspend execution and return FAILURE. // index is reset and children are halted. HaltAllChildren (); return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); return SUCCESS ;","title":"SequenceNode"},{"location":"SequenceNode/#sequencestarnode","text":"Use this ControlNode when you don't want to tick a child more than once. You can customize its behavior using the NodeParameter \"reset_on_failure\". If a child returns FAILURE, the sequence returns FAILURE. [reset_on_failure = \"true\"]: (default) the loop is restarted. [reset_on_failure = \"false\"]: the same failed child is executed again. If a child returns RUNNING, the sequence returns RUNNING. The same child will be ticked again. Example : This is a patrolling agent/robot that must visit locations A, B and C only once . If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK must be checked at every tick, for this reason its parent must be a SequenceNode. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_status == FAILURE ) { // Suspend execution and return FAILURE. // At the next tick, index will be the same. if ( reset_on_failure ) { HaltAllChildren (); index = 0 ; } return FAILURE ; } } // all the children returned success. Return SUCCESS too. index = 0 ; HaltAllChildren (); return SUCCESS ;","title":"SequenceStarNode"},{"location":"getting_started/","text":"Getting started BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS or SmartSoft . You can also statically link it into your application (for example a game). There are some main concepts that you need to understand first. Nodes vs Trees The user must create his/her own ActionNodes and ConditionNodes (LeafNodes) and this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks that you need to compose a complex system. By definition, your custom Nodes are (or should be) highly reusable. Therefore, some wrapping interfaces might be needed at the beginning to adapt your legacy code. The tick() callbacks Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code . What this callback does is up to you. In most of the following examples , our Actions just print messages on the screen of sleep for a certain amount of time to simulate a long calculation. Inheritance vs dependency injection. To create a custom TreeNode, you should inherit from the proper class. For instance, to create your own synchronous Action, you should inherit from the class ActionNodeBase . Alternatively, we provided a mechanism to create a TreeNode passing a function pointer to a wrapper (dependency injection). This approach reduces the amount of boilerplate in your code but has also some limitations; the most important one is that TreeNodes created using function pointers can not support NodeParameters . NodeParameters NodeParameters are conceptually similar to the arguments of a function. They are passed statically when the tree is instantiated. They are expressed as a list of key/value pairs, where both the the key and the value are strings. This is not surprising, since NodeParameters are usually parsed from file. The library provides some methods and utility functions to correctly convert values from string to the desired C++ type.","title":"Main concepts"},{"location":"getting_started/#getting-started","text":"BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS or SmartSoft . You can also statically link it into your application (for example a game). There are some main concepts that you need to understand first.","title":"Getting started"},{"location":"getting_started/#nodes-vs-trees","text":"The user must create his/her own ActionNodes and ConditionNodes (LeafNodes) and this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks that you need to compose a complex system. By definition, your custom Nodes are (or should be) highly reusable. Therefore, some wrapping interfaces might be needed at the beginning to adapt your legacy code.","title":"Nodes vs Trees"},{"location":"getting_started/#the-tick-callbacks","text":"Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code . What this callback does is up to you. In most of the following examples , our Actions just print messages on the screen of sleep for a certain amount of time to simulate a long calculation.","title":"The tick() callbacks"},{"location":"getting_started/#inheritance-vs-dependency-injection","text":"To create a custom TreeNode, you should inherit from the proper class. For instance, to create your own synchronous Action, you should inherit from the class ActionNodeBase . Alternatively, we provided a mechanism to create a TreeNode passing a function pointer to a wrapper (dependency injection). This approach reduces the amount of boilerplate in your code but has also some limitations; the most important one is that TreeNodes created using function pointers can not support NodeParameters .","title":"Inheritance vs dependency injection."},{"location":"getting_started/#nodeparameters","text":"NodeParameters are conceptually similar to the arguments of a function. They are passed statically when the tree is instantiated. They are expressed as a list of key/value pairs, where both the the key and the value are strings. This is not surprising, since NodeParameters are usually parsed from file. The library provides some methods and utility functions to correctly convert values from string to the desired C++ type.","title":"NodeParameters"},{"location":"tutorial_A_create_trees/","text":"How to create a BehaviorTree You have mainly two ways to create Behavior Trees. Statically , at compilation time. Dynamically , at run-time, i.e. parsing a file. You are strongly encourage to use the latter approach , but we will describe the former for the sake of completeness. How to create your own ActionNodes You can find the source code here: dummy_nodes.h The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom ActionNodeBase (synchronous Action) class ApproachObject : public BT :: ActionNodeBase { public : ApproachObject ( const std :: string name ) : BT :: ActionNodeBase ( name ) {} // You must override this virtual function BT :: NodeStatus tick () override { std :: cout ApproachObject: this - name () std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // You must override this virtual function virtual void halt () override { // Do nothing. This is used by asynchronous nodes only. } }; As you can see: Any instance of a TreeNode has a name. This identifier is meant to be user-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must return a NodeStatus, i.e. RUNNING, SUCCESS or FAILURE. The method halt() is used to stop an asynchronous Action. ApproachObject doesn't need it. Alternatively, we can use dependecy injection to create a TreeNode given a function pointer. The only requirement of the functor is to have either one of these signatures: BT :: NodeStatus myFunction () BT :: NodeStatus myFunction ( TreeNode amp ; self ) BT :: NodeStatus SayHello () { std :: cout Robot says Hello std :: endl ; return BT :: NodeStatus :: SUCCESS ; } class GripperInterface { public : GripperInterface () : _open ( true ) {} BT :: NodeStatus open () { _open = true ; std :: cout GripperInterface::open std :: endl ; return BT :: NodeStatus :: SUCCESS ; } BT :: NodeStatus close () { std :: cout GripperInterface::close std :: endl ; _open = false ; return BT :: NodeStatus :: SUCCESS ; } private : bool _open ; }; We can build a SimpleActionNode from any of these functors: SayHello() GripperInterface::open() GripperInterface::close() Tutorial 01: a statically created Tree #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; SequenceNode sequence_root ( sequence ); SimpleActionNode say_hello ( action_hello , std :: bind ( SayHello ) ); SimpleActionNode open_gripper ( open_gripper , std :: bind ( GripperInterface :: open , gi ) ); SimpleActionNode close_gripper ( close_gripper , std :: bind ( GripperInterface :: close , gi ) ); ApproachObject approach_object ( approach_object ); // Add children to the sequence. // They will be executed in the same order they are added. sequence_root . addChild ( say_hello ); sequence_root . addChild ( open_gripper ); sequence_root . addChild ( approach_object ); sequence_root . addChild ( close_gripper ); sequence_root . executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */ Tutorial 02: a dynamically created Tree Give the following XML stored in the file my_tree.xml root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Note that the following syntax is also valid: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence Action ID= SayHello name= action_hello / Action ID= OpenGripper name= open_gripper / Action ID= ApproachObject name= approach_object / Action ID= CloseGripper name= close_gripper / /Sequence /BehaviorTree /root We must first register our custom TreeNodes into the BehaviorTreeFactory and then load the XML from file or text. The identifier used in the XML must coincide with those used to register the TreeNodes. The attribute \"name\" represent the name of the instance and it is optional. #include behavior_tree_core/xml_parsing.h #include Blackboard/blackboard_local.h #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); // IMPORTANT: when the object tree goes out of scope, // all the TreeNodes instances are destroyed auto tree = buildTreeFromFile ( factory , ./my_tree.xml ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Create a Tree"},{"location":"tutorial_A_create_trees/#how-to-create-a-behaviortree","text":"You have mainly two ways to create Behavior Trees. Statically , at compilation time. Dynamically , at run-time, i.e. parsing a file. You are strongly encourage to use the latter approach , but we will describe the former for the sake of completeness.","title":"How to create a BehaviorTree"},{"location":"tutorial_A_create_trees/#how-to-create-your-own-actionnodes","text":"You can find the source code here: dummy_nodes.h The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom ActionNodeBase (synchronous Action) class ApproachObject : public BT :: ActionNodeBase { public : ApproachObject ( const std :: string name ) : BT :: ActionNodeBase ( name ) {} // You must override this virtual function BT :: NodeStatus tick () override { std :: cout ApproachObject: this - name () std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // You must override this virtual function virtual void halt () override { // Do nothing. This is used by asynchronous nodes only. } }; As you can see: Any instance of a TreeNode has a name. This identifier is meant to be user-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must return a NodeStatus, i.e. RUNNING, SUCCESS or FAILURE. The method halt() is used to stop an asynchronous Action. ApproachObject doesn't need it. Alternatively, we can use dependecy injection to create a TreeNode given a function pointer. The only requirement of the functor is to have either one of these signatures: BT :: NodeStatus myFunction () BT :: NodeStatus myFunction ( TreeNode amp ; self ) BT :: NodeStatus SayHello () { std :: cout Robot says Hello std :: endl ; return BT :: NodeStatus :: SUCCESS ; } class GripperInterface { public : GripperInterface () : _open ( true ) {} BT :: NodeStatus open () { _open = true ; std :: cout GripperInterface::open std :: endl ; return BT :: NodeStatus :: SUCCESS ; } BT :: NodeStatus close () { std :: cout GripperInterface::close std :: endl ; _open = false ; return BT :: NodeStatus :: SUCCESS ; } private : bool _open ; }; We can build a SimpleActionNode from any of these functors: SayHello() GripperInterface::open() GripperInterface::close()","title":"How to create your own ActionNodes"},{"location":"tutorial_A_create_trees/#tutorial-01-a-statically-created-tree","text":"#include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; SequenceNode sequence_root ( sequence ); SimpleActionNode say_hello ( action_hello , std :: bind ( SayHello ) ); SimpleActionNode open_gripper ( open_gripper , std :: bind ( GripperInterface :: open , gi ) ); SimpleActionNode close_gripper ( close_gripper , std :: bind ( GripperInterface :: close , gi ) ); ApproachObject approach_object ( approach_object ); // Add children to the sequence. // They will be executed in the same order they are added. sequence_root . addChild ( say_hello ); sequence_root . addChild ( open_gripper ); sequence_root . addChild ( approach_object ); sequence_root . addChild ( close_gripper ); sequence_root . executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Tutorial 01: a statically created Tree"},{"location":"tutorial_A_create_trees/#tutorial-02-a-dynamically-created-tree","text":"Give the following XML stored in the file my_tree.xml root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Note that the following syntax is also valid: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence Action ID= SayHello name= action_hello / Action ID= OpenGripper name= open_gripper / Action ID= ApproachObject name= approach_object / Action ID= CloseGripper name= close_gripper / /Sequence /BehaviorTree /root We must first register our custom TreeNodes into the BehaviorTreeFactory and then load the XML from file or text. The identifier used in the XML must coincide with those used to register the TreeNodes. The attribute \"name\" represent the name of the instance and it is optional. #include behavior_tree_core/xml_parsing.h #include Blackboard/blackboard_local.h #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); // IMPORTANT: when the object tree goes out of scope, // all the TreeNodes instances are destroyed auto tree = buildTreeFromFile ( factory , ./my_tree.xml ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Tutorial 02: a dynamically created Tree"},{"location":"tutorial_B_node_parameters/","text":"How to use NodeParameters NodeParameters are like arguments of a function. They are a list of key/value (both strings) that are usually parsed from file. To create a TreeNodes that accepts NodeParameters, you must follow these rules: Use inheritance. NodeParameters are not supported by SimpleActionNodes nor SimpleConditionNodes . You must provide a constructor with the following signature: MyAction ( const std :: string name , const BT :: NodeParameters params ) The following static member function must be defined: static const BT :: NodeParameters requiredNodeParameters () Example: an action with the parameter \"message\" In the following example you can see a simple sunchronous ActionNodeBase. The parameter with the key \"message\" is passed as a NodeParameter. Its value is printed on console, without any conversion. Please note: The constructor signature. The static method requiredNodeParameters() contains a single key/value pair. The string \"default message\" is the default value. Parameters MUST be accessed using the method getParam() . class SaySomething : public ActionNodeBase { public : SaySomething ( const std :: string name , const NodeParameters params ) : ActionNodeBase ( name , params ) {} virtual NodeStatus tick () override { std :: string msg ; if ( getParam ( message , msg ) == false ) { // if getParam failed, use the default value msg = requiredNodeParameters (). at ( message ); } std :: cout Robot says: msg std :: endl ; return BT :: NodeStatus :: SUCCESS ; } virtual void halt () override {} // It is mandatory to define this static method. static const NodeParameters requiredNodeParameters () { static NodeParameters params = {{ message , default message }}; return params ; } }; Example: conversion to user defined C++ types In the next example we have a user defined type Pose2D . struct Pose2D { double x , y , theta ; }; If we want the method getParam() to be able to parse a string and store its value into a Pose2D, we must provide our own specialization of convertFromString () . In this case, we want to represent Pose2D as three real numbers separated by semicolons. namespace BT { // This template specialization is needed if you want // to AUTOMATICALLY convert a NodeParameter into a Pose2D template Pose2D convertFromString ( const std :: string key ) { // Three real numbers separated by semicolons auto parts = BT :: splitString ( key , ; ); if ( parts . size () != 3 ) { throw std :: runtime_error ( invalid input) ); } else { Pose2D output ; output . x = convertFromString double ( parts [ 0 ] ); output . y = convertFromString double ( parts [ 1 ] ); output . theta = convertFromString double ( parts [ 2 ] ); return output ; } } We now define a synchronous ActionNode called MoveBaseAction . The method getParam() will call the function convertFromString Pose2D () under the hood; alternatively, we can use the latter directly, for instance to convert the default string \"0;0;0\" into a Pose2D. // This is an asynchronous operation that will run in a separate thread. // It requires the NodeParameter goal . // If the key is not provided, the default value 0;0;0 is used instead. class MoveBaseAction : public ActionNode { public : MoveBaseAction ( const std :: string name , const NodeParameters params ) : ActionNode ( name , params ) {} static const BT :: NodeParameters requiredNodeParameters () { static BT :: NodeParameters params = {{ goal , 0;0;0 }}; return params ; } virtual NodeStatus tick () override { Pose2D goal ; if ( getParam Pose2D ( goal , goal ) == false ) { auto default_goal_value = requiredNodeParameters (). at ( goal ); goal = BT :: convertFromString Pose2D ( default_goal_value ); } printf ( [ MoveBase: STARTED ]. goal: x=%.f y=%.1f theta=%.2f \\n , goal . x , goal . y , goal . theta ); halt_requested_ = false ; int count = 0 ; // compute for 250 milliseconds or until halt_requested_ is true while ( ! halt_requested_ count ++ 25 ) { SleepMilliseconds ( 10 ); } std :: cout [ MoveBase: FINISHED ] std :: endl ; return halt_requested_ ? NodeStatus :: SUCCESS : NodeStatus :: SUCCESS ; } virtual void halt () override { halt_requested_ = true ; } private : bool halt_requested_ ; }; NodeParameters in the XML To pass the parameter in the XML, use an attribute with the same name: MoveBaseAction goal= 41.2;13.5;0.7 / SaySomething message= Destination reached /","title":"Add NodeParameters"},{"location":"tutorial_B_node_parameters/#how-to-use-nodeparameters","text":"NodeParameters are like arguments of a function. They are a list of key/value (both strings) that are usually parsed from file. To create a TreeNodes that accepts NodeParameters, you must follow these rules: Use inheritance. NodeParameters are not supported by SimpleActionNodes nor SimpleConditionNodes . You must provide a constructor with the following signature: MyAction ( const std :: string name , const BT :: NodeParameters params ) The following static member function must be defined: static const BT :: NodeParameters requiredNodeParameters ()","title":"How to use NodeParameters"},{"location":"tutorial_B_node_parameters/#example-an-action-with-the-parameter-message","text":"In the following example you can see a simple sunchronous ActionNodeBase. The parameter with the key \"message\" is passed as a NodeParameter. Its value is printed on console, without any conversion. Please note: The constructor signature. The static method requiredNodeParameters() contains a single key/value pair. The string \"default message\" is the default value. Parameters MUST be accessed using the method getParam() . class SaySomething : public ActionNodeBase { public : SaySomething ( const std :: string name , const NodeParameters params ) : ActionNodeBase ( name , params ) {} virtual NodeStatus tick () override { std :: string msg ; if ( getParam ( message , msg ) == false ) { // if getParam failed, use the default value msg = requiredNodeParameters (). at ( message ); } std :: cout Robot says: msg std :: endl ; return BT :: NodeStatus :: SUCCESS ; } virtual void halt () override {} // It is mandatory to define this static method. static const NodeParameters requiredNodeParameters () { static NodeParameters params = {{ message , default message }}; return params ; } };","title":"Example: an action with the parameter \"message\""},{"location":"tutorial_B_node_parameters/#example-conversion-to-user-defined-c-types","text":"In the next example we have a user defined type Pose2D . struct Pose2D { double x , y , theta ; }; If we want the method getParam() to be able to parse a string and store its value into a Pose2D, we must provide our own specialization of convertFromString () . In this case, we want to represent Pose2D as three real numbers separated by semicolons. namespace BT { // This template specialization is needed if you want // to AUTOMATICALLY convert a NodeParameter into a Pose2D template Pose2D convertFromString ( const std :: string key ) { // Three real numbers separated by semicolons auto parts = BT :: splitString ( key , ; ); if ( parts . size () != 3 ) { throw std :: runtime_error ( invalid input) ); } else { Pose2D output ; output . x = convertFromString double ( parts [ 0 ] ); output . y = convertFromString double ( parts [ 1 ] ); output . theta = convertFromString double ( parts [ 2 ] ); return output ; } } We now define a synchronous ActionNode called MoveBaseAction . The method getParam() will call the function convertFromString Pose2D () under the hood; alternatively, we can use the latter directly, for instance to convert the default string \"0;0;0\" into a Pose2D. // This is an asynchronous operation that will run in a separate thread. // It requires the NodeParameter goal . // If the key is not provided, the default value 0;0;0 is used instead. class MoveBaseAction : public ActionNode { public : MoveBaseAction ( const std :: string name , const NodeParameters params ) : ActionNode ( name , params ) {} static const BT :: NodeParameters requiredNodeParameters () { static BT :: NodeParameters params = {{ goal , 0;0;0 }}; return params ; } virtual NodeStatus tick () override { Pose2D goal ; if ( getParam Pose2D ( goal , goal ) == false ) { auto default_goal_value = requiredNodeParameters (). at ( goal ); goal = BT :: convertFromString Pose2D ( default_goal_value ); } printf ( [ MoveBase: STARTED ]. goal: x=%.f y=%.1f theta=%.2f \\n , goal . x , goal . y , goal . theta ); halt_requested_ = false ; int count = 0 ; // compute for 250 milliseconds or until halt_requested_ is true while ( ! halt_requested_ count ++ 25 ) { SleepMilliseconds ( 10 ); } std :: cout [ MoveBase: FINISHED ] std :: endl ; return halt_requested_ ? NodeStatus :: SUCCESS : NodeStatus :: SUCCESS ; } virtual void halt () override { halt_requested_ = true ; } private : bool halt_requested_ ; };","title":"Example: conversion to user defined C++ types"},{"location":"tutorial_B_node_parameters/#nodeparameters-in-the-xml","text":"To pass the parameter in the XML, use an attribute with the same name: MoveBaseAction goal= 41.2;13.5;0.7 / SaySomething message= Destination reached /","title":"NodeParameters in the XML"},{"location":"tutorial_C_blackboard/","text":"Blackboards The blackboard is a a key/value storage that can be shared by all the Nodes of a tree. The key is a string and the value is a type-erased container (called SafeAny::Any ) that allows the user to store any C++ object and to cast it back to its original form. Contrariwise to boost::any and std::any , this container will also try to avoid common overflow and underflow errors. You can't cast a negative number into an unsigned integer , nor a very large number that exceeds 2^8 into a char . If the value is stored as a string, it will use convertFromString T () to cast it to the type T (see previous example ); The user can create his/her own Blackboards backend; it is possible, for instance, to create a persistent blackboard using a database. Assign a blackboard to a tree Let's start with the a SimpleActionNode that writes into the blackboard. // Write into the blackboard key: [GoalPose] // Use this function to create a SimpleActionNode NodeStatus CalculateGoalPose ( TreeNode self ) { const Pose2D mygoal = { 1 , 2 , 3.14 }; // RECOMMENDED: check if the blackboard is nullptr first if ( self . blackboard () ) { // store it in the blackboard self . blackboard () - set ( GoalPose , mygoal ); return NodeStatus :: SUCCESS ; } else { return NodeStatus :: FAILURE ; } } Let's consider now the following XML tree definition: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree SequenceStar CalculateGoalPose/ MoveBase goal= ${GoalPose} / SetBlackboard key= OtherGoal value= -1;3;0.5 / MoveBase goal= ${OtherGoal} / /SequenceStar /BehaviorTree /root The root SequenceStar will execute four actions: CalculateGoalPose sets writes into the key \"GoalPose\". The syntax ${...} tells to MoveBase to read the goal from the key \"GoalPose\" in the blackboard. Alternatively, you can write a key/value pair into the Blackboard using the built-in action SetBlackboard . Similar to step 2. Pose2D is retrieved from \"OtherGoal\". Note For your information, GoalPose is stored as a type erased Pose2D. On the other hand, OtherGoal is stored as a std::string, but is converted to Pose2D the method getParam() using the function convertFromString Pose2D () . In the following code sample we can see two equivalent ways to assign a Blackboard to a tree. int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( CalculateGoalPose , CalculateGoalPose ); factory . registerNodeType MoveBaseAction ( MoveBase ); // create a Blackboard from BlackboardLocal (simple, not persistent, local storage) auto blackboard = Blackboard :: create BlackboardLocal (); // Important: when the object tree goes out of scope, all the TreeNodes are destroyed auto tree = buildTreeFromText ( factory , xml_text , blackboard ); // alternatively: // auto tree = buildTreeFromText(factory, xml_text); // assignBlackboardToEntireTree( tree.root_node, blackboard ); NodeStatus status = NodeStatus :: RUNNING ; while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); SleepMS ( 1 ); // optional sleep to avoid busy loops } return 0 ; } /* Expected output [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.14 [ MoveBase: FINISHED ] [ MoveBase: STARTED ]. goal: x=-1 y=3.0 theta=0.50 [ MoveBase: FINISHED ] */","title":"Use Blackboards"},{"location":"tutorial_C_blackboard/#blackboards","text":"The blackboard is a a key/value storage that can be shared by all the Nodes of a tree. The key is a string and the value is a type-erased container (called SafeAny::Any ) that allows the user to store any C++ object and to cast it back to its original form. Contrariwise to boost::any and std::any , this container will also try to avoid common overflow and underflow errors. You can't cast a negative number into an unsigned integer , nor a very large number that exceeds 2^8 into a char . If the value is stored as a string, it will use convertFromString T () to cast it to the type T (see previous example ); The user can create his/her own Blackboards backend; it is possible, for instance, to create a persistent blackboard using a database.","title":"Blackboards"},{"location":"tutorial_C_blackboard/#assign-a-blackboard-to-a-tree","text":"Let's start with the a SimpleActionNode that writes into the blackboard. // Write into the blackboard key: [GoalPose] // Use this function to create a SimpleActionNode NodeStatus CalculateGoalPose ( TreeNode self ) { const Pose2D mygoal = { 1 , 2 , 3.14 }; // RECOMMENDED: check if the blackboard is nullptr first if ( self . blackboard () ) { // store it in the blackboard self . blackboard () - set ( GoalPose , mygoal ); return NodeStatus :: SUCCESS ; } else { return NodeStatus :: FAILURE ; } } Let's consider now the following XML tree definition: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree SequenceStar CalculateGoalPose/ MoveBase goal= ${GoalPose} / SetBlackboard key= OtherGoal value= -1;3;0.5 / MoveBase goal= ${OtherGoal} / /SequenceStar /BehaviorTree /root The root SequenceStar will execute four actions: CalculateGoalPose sets writes into the key \"GoalPose\". The syntax ${...} tells to MoveBase to read the goal from the key \"GoalPose\" in the blackboard. Alternatively, you can write a key/value pair into the Blackboard using the built-in action SetBlackboard . Similar to step 2. Pose2D is retrieved from \"OtherGoal\". Note For your information, GoalPose is stored as a type erased Pose2D. On the other hand, OtherGoal is stored as a std::string, but is converted to Pose2D the method getParam() using the function convertFromString Pose2D () . In the following code sample we can see two equivalent ways to assign a Blackboard to a tree. int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( CalculateGoalPose , CalculateGoalPose ); factory . registerNodeType MoveBaseAction ( MoveBase ); // create a Blackboard from BlackboardLocal (simple, not persistent, local storage) auto blackboard = Blackboard :: create BlackboardLocal (); // Important: when the object tree goes out of scope, all the TreeNodes are destroyed auto tree = buildTreeFromText ( factory , xml_text , blackboard ); // alternatively: // auto tree = buildTreeFromText(factory, xml_text); // assignBlackboardToEntireTree( tree.root_node, blackboard ); NodeStatus status = NodeStatus :: RUNNING ; while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); SleepMS ( 1 ); // optional sleep to avoid busy loops } return 0 ; } /* Expected output [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.14 [ MoveBase: FINISHED ] [ MoveBase: STARTED ]. goal: x=-1 y=3.0 theta=0.50 [ MoveBase: FINISHED ] */","title":"Assign a blackboard to a tree"},{"location":"tutorial_D_subtrees/","text":"","title":"Compose with Subtrees"},{"location":"tutorial_E_plugins/","text":"Plugins In the previous examples we linked the user-defined nodes where included and linked statically into out projects. We used the BehaviorTreeFactory to registed manualy these custom TreeNodes. We can avoid these steps loading user-defined TreeNodes at run-time using pre-compiled dynamic shared libraries, i.e. plugins . Example Let's consider the first tutorial . We can encapsulate the registration of multiple TreeNodes into a single function like this: BT_REGISTER_NODES ( factory ) { static GripperInterface gi ; // we can t have more than instance factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); factory . registerNodeType SaySomething ( SaySomething ); } BT_REGISTER_NODES is a macro that defines a function which symbol can be loaded from a dynamic library. Note This function must be placed in .cpp file, not an header file. In this particular example we assume that BT_REGISTER_NODES and the definitions of our custom TreeNodes are defined in the file dummy_nodes.cpp . In cmake the plugin can be compiled using the argument SHARED in add_library . add_library ( dummy_nodes SHARED dummy_nodes.cpp ) In Linux the file libdummy_nodes.so is created. Our first tutorial is, as a result, much simpler now: #include behavior_tree_core/xml_parsing.h #include Blackboard/blackboard_local.h // #include dummy_nodes.h YOU DON T NEED THIS ANYMORE using namespace BT ; const std :: string xml_text = R ( root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root ) ; int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerFromPlugin ( ./libdummy_nodes.so ); auto tree = buildTreeFromText ( factory , xml_text ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */ Display the manifest of a plugin BehaviorTree.CPP provides a command line tool called bt_plugin_manifest ; it shows all user-defind TreeNodes registered into the plugin and their corresponding NodeParameters. $ ./bt_plugin_manifest ./libdummy_nodes.so --------------- ApproachObject [Action] NodeParameters: 0 --------------- CloseGripper [Action] NodeParameters: 0 --------------- OpenGripper [Action] NodeParameters: 0 --------------- SayHello [Action] NodeParameters: 0 --------------- SaySomething [Action] NodeParameters: 1: - [Key]: message / [Default]:","title":"Create Plugins"},{"location":"tutorial_E_plugins/#plugins","text":"In the previous examples we linked the user-defined nodes where included and linked statically into out projects. We used the BehaviorTreeFactory to registed manualy these custom TreeNodes. We can avoid these steps loading user-defined TreeNodes at run-time using pre-compiled dynamic shared libraries, i.e. plugins .","title":"Plugins"},{"location":"tutorial_E_plugins/#example","text":"Let's consider the first tutorial . We can encapsulate the registration of multiple TreeNodes into a single function like this: BT_REGISTER_NODES ( factory ) { static GripperInterface gi ; // we can t have more than instance factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); factory . registerNodeType SaySomething ( SaySomething ); } BT_REGISTER_NODES is a macro that defines a function which symbol can be loaded from a dynamic library. Note This function must be placed in .cpp file, not an header file. In this particular example we assume that BT_REGISTER_NODES and the definitions of our custom TreeNodes are defined in the file dummy_nodes.cpp . In cmake the plugin can be compiled using the argument SHARED in add_library . add_library ( dummy_nodes SHARED dummy_nodes.cpp ) In Linux the file libdummy_nodes.so is created. Our first tutorial is, as a result, much simpler now: #include behavior_tree_core/xml_parsing.h #include Blackboard/blackboard_local.h // #include dummy_nodes.h YOU DON T NEED THIS ANYMORE using namespace BT ; const std :: string xml_text = R ( root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root ) ; int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerFromPlugin ( ./libdummy_nodes.so ); auto tree = buildTreeFromText ( factory , xml_text ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Example"},{"location":"tutorial_E_plugins/#display-the-manifest-of-a-plugin","text":"BehaviorTree.CPP provides a command line tool called bt_plugin_manifest ; it shows all user-defind TreeNodes registered into the plugin and their corresponding NodeParameters. $ ./bt_plugin_manifest ./libdummy_nodes.so --------------- ApproachObject [Action] NodeParameters: 0 --------------- CloseGripper [Action] NodeParameters: 0 --------------- OpenGripper [Action] NodeParameters: 0 --------------- SayHello [Action] NodeParameters: 0 --------------- SaySomething [Action] NodeParameters: 1: - [Key]: message / [Default]:","title":"Display the manifest of a plugin"},{"location":"tutorial_F_loggers/","text":"","title":"Log state transitions"}]}