{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home About this library This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions. The problem Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Base Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently ,the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry. What is a Behavior Tree? A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#about-this-library","text":"This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions.","title":"About this library"},{"location":"#the-problem","text":"Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Base Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently ,the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"The problem"},{"location":"#what-is-a-behavior-tree","text":"A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"What is a Behavior Tree?"},{"location":"BT_basics/","text":"Introduction to BTs Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, ie.e the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that triggers an action. All the other nodes of the tree, those which are not leaves, control the \"flow of execution\". To better understand how this flow takes place , imagine a signal, that we will further call \" tick \" that is executed at the root of the tree and propagates through the branches until it reaches a leave. The result of a tick can be either: SUCCESS FAILURE RUNNING The first two, as their names suggest, inform their parent that their operation was a success or a failure. The latter usually means that the execution of the TreeNode is not completed and it needs more time to return a valid result. The result of a node is propagated back to the parent, that will decide which child should be ticked next or will return a result itself. Types of nodes ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes can have only a single child. ActionNodes are leaves and do not have children. The user should implement their own ActionNodes that perform the actual task. ConditionNodes are equivalent to ActionNodes, with the exeption that they are alwais aotmic (they should not return RUNNING) and they should not alter the state of the system. Note Actions and Conditions differ only in terms of semantic . From an implementation point of view they are the same. Learn by example To better understand how a BehaviorTrees work let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously. In future sections we will more thoughtfully analyze asynchronous actions. Sequence Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . It is important to notice that the children of a ControlNode are ordered . In this case the order of execution is from left to right . A Sequence works as described next: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Fallback returns SUCCESS too. Exercise: find the bug! Expand to read the answer. If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseDoor is skipped. Decorators The goal of a DecoratorNode is either to transform the result it received from the child, to terminate the child, or repeat ticking of the child, depending on the type of Decorator. You can create your own Decorators too. The node Negation is a Decorator that inverts the result returned by its child; Negation followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But there is an error. Can you find it? Exercise: find the bug! Expand to read the answer. If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. Fallback FallbackNodes , known also as \"Selector\" in the literature, Is a node that is used to express, as the name suggests, fallback strategies, ie. what to do if a child return FAILURE. In short, it ticks the children in order, as usual from left to right and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequence and Fallbacks can be combined: In the door open? I not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room. \"Fetch me a beer\" revisited We can now improve the \"Fetch Me a Beer\" example, which leaves the door open if the beer was not there. We use the color \"green\" to represent nodes which will return SUCCESS and \"red\" for those which return FAILURE. Black nodes are never executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both the trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS if we managed to open and clode the fridge. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. We can easily double-check that everything works as usual if GrabBeer returns SUCCESS.","title":"The Basics"},{"location":"BT_basics/#introduction-to-bts","text":"Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, ie.e the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that triggers an action. All the other nodes of the tree, those which are not leaves, control the \"flow of execution\". To better understand how this flow takes place , imagine a signal, that we will further call \" tick \" that is executed at the root of the tree and propagates through the branches until it reaches a leave. The result of a tick can be either: SUCCESS FAILURE RUNNING The first two, as their names suggest, inform their parent that their operation was a success or a failure. The latter usually means that the execution of the TreeNode is not completed and it needs more time to return a valid result. The result of a node is propagated back to the parent, that will decide which child should be ticked next or will return a result itself.","title":"Introduction to BTs"},{"location":"BT_basics/#types-of-nodes","text":"ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes can have only a single child. ActionNodes are leaves and do not have children. The user should implement their own ActionNodes that perform the actual task. ConditionNodes are equivalent to ActionNodes, with the exeption that they are alwais aotmic (they should not return RUNNING) and they should not alter the state of the system. Note Actions and Conditions differ only in terms of semantic . From an implementation point of view they are the same.","title":"Types of nodes"},{"location":"BT_basics/#learn-by-example","text":"To better understand how a BehaviorTrees work let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously. In future sections we will more thoughtfully analyze asynchronous actions.","title":"Learn by example"},{"location":"BT_basics/#sequence","text":"Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . It is important to notice that the children of a ControlNode are ordered . In this case the order of execution is from left to right . A Sequence works as described next: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Fallback returns SUCCESS too. Exercise: find the bug! Expand to read the answer. If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseDoor is skipped.","title":"Sequence"},{"location":"BT_basics/#decorators","text":"The goal of a DecoratorNode is either to transform the result it received from the child, to terminate the child, or repeat ticking of the child, depending on the type of Decorator. You can create your own Decorators too. The node Negation is a Decorator that inverts the result returned by its child; Negation followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But there is an error. Can you find it? Exercise: find the bug! Expand to read the answer. If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted.","title":"Decorators"},{"location":"BT_basics/#fallback","text":"FallbackNodes , known also as \"Selector\" in the literature, Is a node that is used to express, as the name suggests, fallback strategies, ie. what to do if a child return FAILURE. In short, it ticks the children in order, as usual from left to right and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequence and Fallbacks can be combined: In the door open? I not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room.","title":"Fallback"},{"location":"BT_basics/#fetch-me-a-beer-revisited","text":"We can now improve the \"Fetch Me a Beer\" example, which leaves the door open if the beer was not there. We use the color \"green\" to represent nodes which will return SUCCESS and \"red\" for those which return FAILURE. Black nodes are never executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both the trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS if we managed to open and clode the fridge. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. We can easily double-check that everything works as usual if GrabBeer returns SUCCESS.","title":"\"Fetch me a beer\" revisited"},{"location":"BlackBoard/","text":"","title":"The BlackBoard"},{"location":"ControlNode/","text":"ControlNodes ControlNodes can have multiple children. Children are always ordered and it is up to the ControlNode itself to decide if and when a child should be ticked. SequenceNode The SequenceNode is used to execute the children in a sequence. It ticks its children as long as they returns SUCCESS. Before ticking the first child, Sequence becomes RUNNING . If a child return SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the Sequence returns SUCCESS . If a child returns RUNNING , Sequence suspends and returns RUNNING . If a child returns FAILURE , Sequence stops and returns FAILURE .","title":"ControlNodes"},{"location":"ControlNode/#controlnodes","text":"ControlNodes can have multiple children. Children are always ordered and it is up to the ControlNode itself to decide if and when a child should be ticked.","title":"ControlNodes"},{"location":"ControlNode/#sequencenode","text":"The SequenceNode is used to execute the children in a sequence. It ticks its children as long as they returns SUCCESS. Before ticking the first child, Sequence becomes RUNNING . If a child return SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the Sequence returns SUCCESS . If a child returns RUNNING , Sequence suspends and returns RUNNING . If a child returns FAILURE , Sequence stops and returns FAILURE .","title":"SequenceNode"},{"location":"DecoratorNode/","text":"Decorators A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked. InverterNode Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too. ForceSuccessNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS. ForceFailureNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE. RepeatNode Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too. RetryNode Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"Decorators Nodes"},{"location":"DecoratorNode/#decorators","text":"A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked.","title":"Decorators"},{"location":"DecoratorNode/#inverternode","text":"Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too.","title":"InverterNode"},{"location":"DecoratorNode/#forcesuccessnode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS.","title":"ForceSuccessNode"},{"location":"DecoratorNode/#forcefailurenode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE.","title":"ForceFailureNode"},{"location":"DecoratorNode/#repeatnode","text":"Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too.","title":"RepeatNode"},{"location":"DecoratorNode/#retrynode","text":"Tick the child up to N times, where N is passed as a NodeParameter , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"RetryNode"},{"location":"FallbackNode/","text":"Fallback This family of nodes are known as \"Selector\" or, sometimes, \"Priority\" in other frameworks. Its purpose is to try different strategies, until we find one that \"works\". Currently, there is only a single type of node called \"FallbackNode\". FallbackNode The SequenceNode is used to execute the children in a sequence. Before ticking the first child, Fallback becomes RUNNING . If a child returns FAILURE , it ticks the next child. If the last child returns FAILURE too, all the children are halted and the Sequence returns FAILURE . If a child returns RUNNING , Fallback suspends and returns RUNNING . If a child returns SUCCESS , Fallback stops and returns SUCCESS . Example : Try different strategies to open the door. Check first if it is open already. See the pseudocode // At the beginning, start from first child if ( state != RUNNING ) { index = 0 ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == FAILURE ) { // continue the while loop index ++ ; } else if ( child_state == SUCCESS ) { // Suspend execution and return SUCCESS. // index is reset and children are halted. state = SUCCESS ; index = 0 ; HaltAllChildren (); return state ; } } // all the children returned failure. Return FAILURE too. state = FAILURE ; HaltAllChildren (); return state ;","title":"Fallback Nodes"},{"location":"FallbackNode/#fallback","text":"This family of nodes are known as \"Selector\" or, sometimes, \"Priority\" in other frameworks. Its purpose is to try different strategies, until we find one that \"works\". Currently, there is only a single type of node called \"FallbackNode\".","title":"Fallback"},{"location":"FallbackNode/#fallbacknode","text":"The SequenceNode is used to execute the children in a sequence. Before ticking the first child, Fallback becomes RUNNING . If a child returns FAILURE , it ticks the next child. If the last child returns FAILURE too, all the children are halted and the Sequence returns FAILURE . If a child returns RUNNING , Fallback suspends and returns RUNNING . If a child returns SUCCESS , Fallback stops and returns SUCCESS . Example : Try different strategies to open the door. Check first if it is open already. See the pseudocode // At the beginning, start from first child if ( state != RUNNING ) { index = 0 ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == FAILURE ) { // continue the while loop index ++ ; } else if ( child_state == SUCCESS ) { // Suspend execution and return SUCCESS. // index is reset and children are halted. state = SUCCESS ; index = 0 ; HaltAllChildren (); return state ; } } // all the children returned failure. Return FAILURE too. state = FAILURE ; HaltAllChildren (); return state ;","title":"FallbackNode"},{"location":"NodeParameters/","text":"NodeParameters","title":"NodeParameters"},{"location":"NodeParameters/#nodeparameters","text":"","title":"NodeParameters"},{"location":"SequenceNode/","text":"Sequences A Sequence ticks all it's children, from left to right, as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Here we introduce different kinds of sequence nodes: SequenceNode SequenceStarNode SequenceAllNode The best way to determine which one should be used is to ask yourself: Q: What should I do if one of the childs returns FAILURE? Use SequenceNode if you answer is: A: Restart the entire sequence Use SequenceStarNode if, instead, the answer is: A: Try again to execute the child that failed. Do not re-tick children which succeeded already. Last, use SequenceAllNode when you want all the children to be ticked at least once. If any of them failed, the SequenceAllNode returns FAILURE. The shared logic is: Before ticking the first child, sequence becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . If a child returns RUNNING , the sequence suspends and returns RUNNING . The next time it is ticked, it will tick the same child again. The three sequences differ in what they do if a child returns FAILURE. SequenceNode (default) If a child returns FAILURE, the sequence returns FAILURE. Reset the index and halt all the children. The entire sequence will be executed again at the next tick. Example : This tree represents the behavior of a sniper in a computer game. If any of these conditions/actions fails, the entire sequence is executed again from the beginning. See the pseudocode // At the beginning, start from first child if ( state != RUNNING ) { index = 0 ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_state == FAILURE ) { // Suspend execution and return FAILURE. // index is reset and children are halted. state = FAILURE ; index = 0 ; HaltAllChildren (); return state ; } } // all the children returned success. Return SUCCESS too. state = SUCCESS ; HaltAllChildren (); return state ; SequenceStarNode If a child returns FAILURE, the sequence returns FAILURE. At the next tick, the failed child is executed again. Example : This is a patrolling agent/robot that must visit locations A, B and C only once. If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK is visited at every tick, because its parent is a normal SequenceNode. See the pseudocode // index is initialized to 0 in the constructor state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_state == FAILURE ) { // Suspend execution and return FAILURE. // At the next tick, index will be the same. state = FAILURE ; return state ; } } // all the children returned success. Return SUCCESS too. state = SUCCESS ; HaltAllChildren (); return state ; SequenceAllNode All the children are executed at least once. If any child returned FAILURE, the sequence is not interrupted but the sequence itself will return FAILURE. Example : If the door of the fridge was succesfully opened, grab a beer. CloseFridge is always executed, even when GrabBeer failed. See the pseudocode if ( state != RUNNING ) { index = 0 ; at_least_one_failure = false ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { index ++ ; } else if ( child_state == FAILURE ) { index ++ ; at_least_one_failure = true ; } } // If any child failed, the entire sequence fails. state = at_least_one_failure ? FAILURE : SUCCESS ; HaltAllChildren (); return state ;","title":"Sequence Nodes"},{"location":"SequenceNode/#sequences","text":"A Sequence ticks all it's children, from left to right, as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Here we introduce different kinds of sequence nodes: SequenceNode SequenceStarNode SequenceAllNode The best way to determine which one should be used is to ask yourself: Q: What should I do if one of the childs returns FAILURE? Use SequenceNode if you answer is: A: Restart the entire sequence Use SequenceStarNode if, instead, the answer is: A: Try again to execute the child that failed. Do not re-tick children which succeeded already. Last, use SequenceAllNode when you want all the children to be ticked at least once. If any of them failed, the SequenceAllNode returns FAILURE. The shared logic is: Before ticking the first child, sequence becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . If a child returns RUNNING , the sequence suspends and returns RUNNING . The next time it is ticked, it will tick the same child again. The three sequences differ in what they do if a child returns FAILURE.","title":"Sequences"},{"location":"SequenceNode/#sequencenode-default","text":"If a child returns FAILURE, the sequence returns FAILURE. Reset the index and halt all the children. The entire sequence will be executed again at the next tick. Example : This tree represents the behavior of a sniper in a computer game. If any of these conditions/actions fails, the entire sequence is executed again from the beginning. See the pseudocode // At the beginning, start from first child if ( state != RUNNING ) { index = 0 ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_state == FAILURE ) { // Suspend execution and return FAILURE. // index is reset and children are halted. state = FAILURE ; index = 0 ; HaltAllChildren (); return state ; } } // all the children returned success. Return SUCCESS too. state = SUCCESS ; HaltAllChildren (); return state ;","title":"SequenceNode (default)"},{"location":"SequenceNode/#sequencestarnode","text":"If a child returns FAILURE, the sequence returns FAILURE. At the next tick, the failed child is executed again. Example : This is a patrolling agent/robot that must visit locations A, B and C only once. If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK is visited at every tick, because its parent is a normal SequenceNode. See the pseudocode // index is initialized to 0 in the constructor state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { // continue the while loop index ++ ; } else if ( child_state == FAILURE ) { // Suspend execution and return FAILURE. // At the next tick, index will be the same. state = FAILURE ; return state ; } } // all the children returned success. Return SUCCESS too. state = SUCCESS ; HaltAllChildren (); return state ;","title":"SequenceStarNode"},{"location":"SequenceNode/#sequenceallnode","text":"All the children are executed at least once. If any child returned FAILURE, the sequence is not interrupted but the sequence itself will return FAILURE. Example : If the door of the fridge was succesfully opened, grab a beer. CloseFridge is always executed, even when GrabBeer failed. See the pseudocode if ( state != RUNNING ) { index = 0 ; at_least_one_failure = false ; } state = RUNNING ; while ( index number_of_children ) { child_state = child [ index ] - tick (); if ( child_state == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. state = RUNNING ; return state ; } else if ( child_state == SUCCESS ) { index ++ ; } else if ( child_state == FAILURE ) { index ++ ; at_least_one_failure = true ; } } // If any child failed, the entire sequence fails. state = at_least_one_failure ? FAILURE : SUCCESS ; HaltAllChildren (); return state ;","title":"SequenceAllNode"},{"location":"getting_started/","text":"Getting started BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS of SmartSoft . You can also statically link it into your application (for example a game). There are some main concepts that you need to understand first. Nodes vs Trees The user must create his/her own ActionNodes and ConditionNodes (LeafeNodes) and this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks that you need to compose a complex system. Keep in mind that, by definition, your custom Nodes are (or should be) highly reusable. Therefore, even if some heavy litfing might be needed at the beginning, the added productivity will compensate that. The tick() callbacks Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code. What this callback does is up to you. Don't be puzzled by the fact that in most of the examples the Actions just print messages on the screen of sleep for a certain amount of time to simulate a long calculation. Inheritance vs dependency injection. To create a custom TreeNode, you should inherit from the proper type. For instance, to create your own Action, you should inherit from the class ActionNodeBase . Alternatively, we provided a mechanism to create a TreeNode passins a function pointer to a wrapper. This approach reduce the amount of boilerplate in your code but has also some limitations; the most important one is that TreeNodes created using function pointers can not support NodeParameters. NodeParameters NodeParameters are conceptually similar to the arguments of a function. They are passed statically when the tree is instantiated. They are expressed as a list of key/value pairs, where both the the key and the value are strings. This is not surprising, since NodeParameters are usually parsed from file. The library provides some methods and utlity functions to correctly convert values from string to the proper C++ type.","title":"Main concepts"},{"location":"getting_started/#getting-started","text":"BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS of SmartSoft . You can also statically link it into your application (for example a game). There are some main concepts that you need to understand first.","title":"Getting started"},{"location":"getting_started/#nodes-vs-trees","text":"The user must create his/her own ActionNodes and ConditionNodes (LeafeNodes) and this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks that you need to compose a complex system. Keep in mind that, by definition, your custom Nodes are (or should be) highly reusable. Therefore, even if some heavy litfing might be needed at the beginning, the added productivity will compensate that.","title":"Nodes vs Trees"},{"location":"getting_started/#the-tick-callbacks","text":"Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code. What this callback does is up to you. Don't be puzzled by the fact that in most of the examples the Actions just print messages on the screen of sleep for a certain amount of time to simulate a long calculation.","title":"The tick() callbacks"},{"location":"getting_started/#inheritance-vs-dependency-injection","text":"To create a custom TreeNode, you should inherit from the proper type. For instance, to create your own Action, you should inherit from the class ActionNodeBase . Alternatively, we provided a mechanism to create a TreeNode passins a function pointer to a wrapper. This approach reduce the amount of boilerplate in your code but has also some limitations; the most important one is that TreeNodes created using function pointers can not support NodeParameters.","title":"Inheritance vs dependency injection."},{"location":"getting_started/#nodeparameters","text":"NodeParameters are conceptually similar to the arguments of a function. They are passed statically when the tree is instantiated. They are expressed as a list of key/value pairs, where both the the key and the value are strings. This is not surprising, since NodeParameters are usually parsed from file. The library provides some methods and utlity functions to correctly convert values from string to the proper C++ type.","title":"NodeParameters"},{"location":"tutorial_A_create_trees/","text":"How to create Trees You have mainly two ways to create Behavior Trees. Statically, at compilation time . Dynamically, at run-time , i.e. parsing a file. You are strongly encourage to use the latter approach, but we will describe the first for the sake of completeness. How to create your own ActionNodes You can find the source code here: dummy_nodes.h The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom ActionNodeBase (synchronous Action) class ApproachObject : public BT :: ActionNodeBase { public : ApproachObject ( const std :: string name ) : BT :: ActionNodeBase ( name ) {} // You must override the virtual function tick() BT :: NodeStatus tick () override { std :: cout ApproachObject: this - name () std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // You must override the virtual function halt() virtual void halt () override { // Do nothing. This is used by asynchronous nodes. } }; As you can see: Any TreeNode as a name. This identifier is meant to be user-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must return a NodeStatus RUNNING, SUCCESS or FAILURE. The method halt() is used to stop an asynchronous Action. ApproachObject doesn't need it. Alternatively, we can use dependecy injection to create a TreeNode given a functor__ (function pointer). The only requirement of the funtor is to have either one of these signatures: BT::NodeStatus myFunction() BT::NodeStatus myFunction(TreeNode self) BT :: NodeStatus SayHello () { std :: cout Robot says: \\ Hello!!! \\ std :: endl ; return BT :: NodeStatus :: SUCCESS ; } class GripperInterface { public : GripperInterface () : _open ( true ) {} BT :: NodeStatus open () { _open = true ; std :: cout GripperInterface::open std :: endl ; return BT :: NodeStatus :: SUCCESS ; } BT :: NodeStatus close () { std :: cout GripperInterface::close std :: endl ; _open = false ; return BT :: NodeStatus :: SUCCESS ; } private : bool _open ; }; In the example, we can build a SimpleActionNode from: SayHello() GripperInterface::open() GripperInterface::close() Tutorial 01: a statically created Tree #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; SequenceNode sequence_root ( sequence ); SimpleActionNode say_hello ( action_hello , std :: bind ( SayHello ) ); SimpleActionNode open_gripper ( open_gripper , std :: bind ( GripperInterface :: open , gi ) ); SimpleActionNode close_gripper ( close_gripper , std :: bind ( GripperInterface :: close , gi ) ); ApproachObject approach_object ( approach_object ); // Add children to the sequence. // They will be executed in the same order they are added. sequence_root . addChild ( say_hello ); sequence_root . addChild ( open_gripper ); sequence_root . addChild ( approach_object ); sequence_root . addChild ( close_gripper ); sequence_root . executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */ Tutorial 02: a dynamically created Tree Give the following XML stored in the file my_tree.xml root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root We must first register our custom TreeNodes into the BehaviorTreeFactory and the load the XMl from file or text. #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); // IMPORTANT: when the object tree goes out of scope, // all the TreeNodes are destroyed auto tree = buildTreeFromFile ( factory , ./my_tree.xml ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"How to create a Tree"},{"location":"tutorial_A_create_trees/#how-to-create-trees","text":"You have mainly two ways to create Behavior Trees. Statically, at compilation time . Dynamically, at run-time , i.e. parsing a file. You are strongly encourage to use the latter approach, but we will describe the first for the sake of completeness.","title":"How to create Trees"},{"location":"tutorial_A_create_trees/#how-to-create-your-own-actionnodes","text":"You can find the source code here: dummy_nodes.h The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom ActionNodeBase (synchronous Action) class ApproachObject : public BT :: ActionNodeBase { public : ApproachObject ( const std :: string name ) : BT :: ActionNodeBase ( name ) {} // You must override the virtual function tick() BT :: NodeStatus tick () override { std :: cout ApproachObject: this - name () std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // You must override the virtual function halt() virtual void halt () override { // Do nothing. This is used by asynchronous nodes. } }; As you can see: Any TreeNode as a name. This identifier is meant to be user-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must return a NodeStatus RUNNING, SUCCESS or FAILURE. The method halt() is used to stop an asynchronous Action. ApproachObject doesn't need it. Alternatively, we can use dependecy injection to create a TreeNode given a functor__ (function pointer). The only requirement of the funtor is to have either one of these signatures: BT::NodeStatus myFunction() BT::NodeStatus myFunction(TreeNode self) BT :: NodeStatus SayHello () { std :: cout Robot says: \\ Hello!!! \\ std :: endl ; return BT :: NodeStatus :: SUCCESS ; } class GripperInterface { public : GripperInterface () : _open ( true ) {} BT :: NodeStatus open () { _open = true ; std :: cout GripperInterface::open std :: endl ; return BT :: NodeStatus :: SUCCESS ; } BT :: NodeStatus close () { std :: cout GripperInterface::close std :: endl ; _open = false ; return BT :: NodeStatus :: SUCCESS ; } private : bool _open ; }; In the example, we can build a SimpleActionNode from: SayHello() GripperInterface::open() GripperInterface::close()","title":"How to create your own ActionNodes"},{"location":"tutorial_A_create_trees/#tutorial-01-a-statically-created-tree","text":"#include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; SequenceNode sequence_root ( sequence ); SimpleActionNode say_hello ( action_hello , std :: bind ( SayHello ) ); SimpleActionNode open_gripper ( open_gripper , std :: bind ( GripperInterface :: open , gi ) ); SimpleActionNode close_gripper ( close_gripper , std :: bind ( GripperInterface :: close , gi ) ); ApproachObject approach_object ( approach_object ); // Add children to the sequence. // They will be executed in the same order they are added. sequence_root . addChild ( say_hello ); sequence_root . addChild ( open_gripper ); sequence_root . addChild ( approach_object ); sequence_root . addChild ( close_gripper ); sequence_root . executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Tutorial 01: a statically created Tree"},{"location":"tutorial_A_create_trees/#tutorial-02-a-dynamically-created-tree","text":"Give the following XML stored in the file my_tree.xml root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root We must first register our custom TreeNodes into the BehaviorTreeFactory and the load the XMl from file or text. #include dummy_nodes.h int main () { using namespace BT ; using namespace DummyNodes ; GripperInterface gi ; BehaviorTreeFactory factory ; factory . registerSimpleAction ( SayHello , std :: bind ( SayHello ) ); factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gi )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gi )); factory . registerNodeType ApproachObject ( ApproachObject ); // IMPORTANT: when the object tree goes out of scope, // all the TreeNodes are destroyed auto tree = buildTreeFromFile ( factory , ./my_tree.xml ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Robot says: Hello!!! GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Tutorial 02: a dynamically created Tree"}]}